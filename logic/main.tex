\section{Функции алгебры логики}
С точки зрения алгебры высказываний логические операции полностью характеризыются таблицами истинности,
при этом можно забыть о том, что мы рассматриваем какие-то операции на высказываниях и иметь дело с самими таблицами истинности.
Таким образом, мы приходим к понятию функций алгебры логики.
Однако не следует забывать о логических связках так как они проясняют целый ряд соотношений в алгебре логики.
В частности в обозначениях некоторых функций алгебры логики совпадают с обозначениями логических связок.
Будем употреблять вместо ``истины'' и ``ложь'' - ``единицу'' и ``ноль'' соотвественно.

Определение:
Функцией алгебры логики и функцией буля $f(x_1, x_2, ..., x_n)$ называется функция принимающая значения $1$ и $0$ и аргументы которой принимают значения 1 или 0. Такая функция имеет тип:

${0, 1}^n -> {0, 1}$

Ясно что тождественно истинные представляют собой постоянные функции, а две равносильные формулы выражаю одну и ту же функцию. Будем говорить что функция f(x_1, ...,  x_i-1, 0, x_i+1, ..., x_n) + f(x_1, ..., x_i-1, 1, x_i+1, ..., x_n)Существенно зависит от переменной x_i. переменные от которых функция существенно зависит называют существенными переменными. Остальные фиктивынми.

Будем отождествялть функции, из которых добавлением фиктивных переменных можно получить одну и ту же функцию.
Фуникция может быть задана таблицей своих значений. Другой способ записи логической функции это формула. Таким образом, любую логическую функцию, записанную таблицей можно представить в виде формулы и наоборот. Пусть f, g функции алгебры логики и x_1, x_2, ..., x_n - совокупность аргументов, входящих по краней мере в одну из этих функций. Добавляя необходимые фиктивные аргументы можно считать что x_1, x_2, ..., x_n входят в каждую из функций f, g. Будем говорить что функции f, g равны и писать f = g, если при всех значениях x_1, x_2, ...., x_n значения f и g совпадают.

Введем специальные обозначения для основных функций алгебры логики

x принадлежит {1, 2}

0(x) = 0
1(x) = 1
i(x) = x
Г x = 0, x = 1
Г x = 1, x = 0

x & y = 1, x = y = 1
x & y = 0, или x, или y = 0

x v y = 0, x = y = 0
x v y = 1, если x = 1  или y = 1

x + y = 0, x == y
x + y = 1, x != y

x->y = !xvy
x <-> y = !(x+y)
A ~ B <=> f(A) = f(B)

Каждой формуле А алгебры высказываний можно сопоставить функцию f(A) алгебры логики, так что A эквивалентно B тогда и только тогда когда f(A) = f(B)

В самом деле, пусть x_1, x_2, ..., x_n - все высказывательные переменные, которые используются в записи формул A и B.

f(X_i) = x_i, если P и Q - какие либо формулы то полагаем,
f(!P) = !f(P)
f(P&Q) = f(P)f(Q)
f(PvQ) = f(P)vf(Q)
f(И) = 1, f(Л) - 0
f(x->y) = f(x) -> f(y)

Можно проверить, что построенные таким образом функции алгебры логики, f(A) и f(B) по эквивалентным формулам A и B равны.

A = !(X_1 & X_2)
B = ! (X_1) & ! (x_2)

f(A) =
f(B) =


Докажем что f(A) == f(B), для это составим таблицы значений этих функций используя определение основных функций алгебры логики, через которые выражены f(A) и f(B)


x_1 | x_2 | f(A) | f(B)


Мы видим что таблицы функций f(A) и f(B) совпадают, то есть f(A) == f(B).

Выясним каково число функций n переменных.
Очевидно каждую функцию алгебры логики можно задать с помощью таблиц истинности, которая будет содержать 2^n строк, следовательно каждая функция n переменных принимает 2^n значений состоящих из нулей и единиц, таким образом, функция полностью определяетс янабором значений из нулей и единиц длинны 2^n. Общее число наборов состоящих из нулей и единиц длинны 2^n равно 2^2^n значит число различных функций от n переменных равно 2^2^n в частности различных функций одной переменной.

Выпишем все фунции алгебры логики одной переменной.

из этой таблицы следует что две функции одной переменной будут постоянными (f1, f4).

x f1(x) f2(x) f3(x) f4(x)
1 1 1 0 0
0 1 0 1 0

x y f_1 f_2 f_3 f_4 f_5 f_6 f_7 f_8 f_9 f_10 f_11 f_12 f_13 f_14 f_15 f_16
1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0
1 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 0 0
0 1 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0 0
0 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0

f_1 = 1
f_16 = 0

\section{Представление произвольной функции алгебры логики в виде формулы алгебры логики}
Пусть f(x1, x_2, ..., x_n) - произвольная функция алгебры логики от n переменных. Рассмотрим формулу:

$$ (F(1, 1, ..., 1)&x_1&x_2&...&x_n)V $$
$$ (F(1, 1, ..., 0)&x_1&x_2&...&!x_n)V $$
$$ ................................... $$
$$ (F(0, 0, ..., 0)&!x_1&!x_2&...&!x_n)V $$

Которая составлена следующим образом - каждое слагаемое этой логической суммы пердстваляет конъюнкцию, в которой первый член язвляется значением функции $F$, при некоторых определенных значениях переменных x_1, x_2, ..., x_n. Остальные же члены конъюнкции представляют собой переменные и их отрицания. При этом под знаком отрицания находятся те и только те и только те переменные, которые в первом члене конъюнкции имеют значение ноль. Вместе с тем формула 1 содержит в виде логических слагаемых всевозможные конъюнкции указанного вида, ясно что формула 1 полностью определяет функцию $F(x_1, x_2, ..., x_n)$. Иначе говоря, значение функции $F$ и формулы 1 совпадают на всех наборах значений переменных x1, x_2, ..., x_n.
Например, если x_1 == 0, x_2, ..., x_n = 1, то функция F принимает значение F(0, 1, ..., 1) при этом логическое слагаемое входящее в формулу принимает такое же значение F, все остальные логические слагаемые формулы 1 имеют значение 0.

Действительно в них знаки отрицания над переменными распределяются иначе чем в рассмотренном слагаемом, но тогда при замене переменных теми же значениями в конъюнкцию войде символ 0, без знака отрицания и символ 1 под знаком отрицания. В таком случае один из членов конъюнкции имеет значение ноль. А потому вся конъюнкция имеет значение 0.

В связи с этим на основании равносильности x v 0 = x значением функции 1 является F(0, 1, ..., 1)
Ясно что вид формулы 1 может быть значительно упрощен, если в ней отбросить те логические слагаемые, в которой первый член конъюнкции имеет значение 0. И следовательно вся конъюнкция имеет значение 0. Если же в логическом слагаемом первый член конъюнкции имеет значение единица, то пользуясь равносильностью 1 & x = x, этот член конъюнкции можно не выписывать.
Таким образом получается формула один, которая сожержит только элементарные переменные высказывания и обладает следующими свойствами:

Каждое логическое слагаемое формулы содержит все переменные, входящие в функцию F(x_1, x_2, ..., x_n)
Все логические слагаемые различны.
Ни одно логическое слагаемое формулы не содержит одновременно переменную и ее отрицание
Ни одно логическое слагаемое формулы не содержит одну и ту же переменную дважды

Перечисленные свойства будем называть свойствами совершенства. Из приведенныз рассуждений видно, что каждой нетождественно ложной функции соотвествует единственная формула указанного вида.

Если функция F(x_1, x_2, ..., x_n) задана таблицей истинности, то соответсвующая ей формула может быть получена проще.
Для каждого набора значений переменных, на котором функция $F$ принимает значение единицу, запишем конъюнкцию элементарных переменных высказываения. Возьмем значение x_n, если значение x_n на указанном наборе есть единица и !x_n, если !x_n = 1
Дизъюнкция записанных конъюнкиций и будет формулой.

x_1 x_2 x_3 F(x_1, x_2, x_3)
1 1 1 0
1 1 0 1 x_1 & x_2 & !x_3 V
1 0 1 1 x_1 & !x_2 & x_3 V
1 0 0 0
0 1 1 0
0 1 0 1 !x_1 & x_2 & !x_3 V
0 0 1 0
0 0 0 1 !x_1 & !x_2 & !x_3 V

Искомая формула обладает свойствами совершенства
Основная операция, которую можно производить над функциями алгебры логики, называется суперпозицией.

Интуитивный смысл этого понятия состоит в том что аргументы функции посдставляются в другие функции и эта процедура может повторятся. Можно сказать что формула это суперпозиция основных функций !x, x|y, x&y, x->y, x~y;

Введенное ранее понятие эквивалентности формул очевидно согласуется с определением равенства функций.

Основные эквивалентности формул перечисленные в пункте 5 можно записать как равенство функций алгебры логики.

!! x = x
xy = yx
x v y = y v x
x(yz) = (xy)z
xv(yvz) = xy

Используя алгебраическую терминологию можно сказать что равенство 2 и 3, 4 и 5 выражают коммутативность и ассоциативность конъюнкции и дизъюнкции. Равенства 6 и 7 выражают дистрибутивность конъюнкции относительно дизъюнкции и соотвественно дистрибутивность дизъюнкции относительно конъюнкции. Эти свойства позволяют преобразовывать выражения по правилам умножения многочлена на многочлен учитывая 7.

Пункт 8. нормальные формы.
Ранее был изложен способ выяснения является ли данная функция ТИ формулой, ТЛ формулой или является выполнимой с помощью таблиц истинности.

Если переменных много то этот процесс долгий и скучный.
Существует другой способ решения этого вопроса. Основанный на приведении к так называемой ``нормальной'' форме.
Пусть задана система высказывательных элементов. X_1, X_2, ..., X_N

Элементарной дизъюнкцией, конъюнкцией системы X_1, X_2, ..., X_N называется дизънкция некоторых переменных этой системы или их отрицаний.

Элементарная дизъюнкиция называется правильной, если в нее каждая переменная входит не более одного раза, включая и ее вхождение под знаком отрицания. Если в ЭД(ЭК) входит каждая высказывательная переменная системы, с отрицанием или без него.
При том только один раз, то она называется полной элементарной дизъюнкцией.

x_1 v x_2 v !x_3
F(x_1, x_2, x_3)

% МЕТОДИЧКА 2590

x_1 & x_2 & x_3,
x_1 & x_2 & !x_3,
x_1 & !x_2 & x_3,
x_1 & !x_2 & !x_3,
!x_1 & x_2 & x_3,
!x_1 & x_2 & !x_3,
!x_1 & !x_2 & x_3,
!x_1 & !x_2 & !x_3,

Если в полных элементарных конъюнкциях заминить знаки на дизънкцию, то получим все полные элементарные дизънкции высказывательных переменных x_1, x_2, x_3.

Ясно что для n - высказывательных перменных существует 2^n неэквивалентных полных элементарных конъюнкций.
И такое же число неэквивалентных элементарных дизъюнкций.

Рассмотрим какую-нибудь полную элементарную дизънкцию $\sigma$ она может принять значение ноль только для одного набора значений высказывательных переменных.

x_1, x_2, ..., x_n. А именно, когда каждая x_i входящее в $\sigma$ без отрицания имеет значение 0, а с отрицанием значение 1.

Систему значений высказывательных переменных, для которых данная полная элементарная дизъюнкция принимает значение 0 назовем нулем полной элементарной дизъюнкции. Двойственным образом, полная элементарная конъюнкция может принимать значение 1 только для одного набора высказывательных переменных x_1, x_2, ..., x_n. Когда любое x_i входящее в $\sigma$ без отрицания имеет значение 1, а с отрицанием значение 0. Такую систему значений высказывательных перменных назовем единицей полной элементарной конъюнкции.

Единицами полной элементарной конъюнкции 1, 1, 1 ...............

Теорема 1.

Чтобы элементарная дизъюнкция была тождественно истинной, необходимо и достаточно чтобы в ней содержалось вместе с некоторой высказывательной переменной x_i и ее отрицание !x_i.

Теорема 2.

Чтобы элементарная конъюнкция была тождественно ложной необходимо и достаточно чтобы в ней содержалась хотя бы одна пара множителей из которых один является отрицанием другого.


Формула A называется КНФ системы высказывательных переменных x_1, x_2, ..., x_n, если A  является конъюнкцией элементарных дизъюнкций высказывательных переменных этой системы.

Формула A называется ДНФ системы высказывательных переменных x_1, x_2, ..., x_n, если A  является дизъюнкцией элементарных конъюнкиций высказывательных переменных этой системы.

Как уже говорилось ранее, все логическии операции можно свести к трем дизъюнкцию, конъюнкцию и отрицание.
Предположим, что формулы для которых мы будем определеять нормальную форму содержат только эти операции.
Знак отрицания можно предполагать отнесенным только к элементарным высказываниям.

Как мы видели выше, с формулой составленных из переменных и их отрицаний при помощи операции конъюнкции и дизъюнкции можно производить такие же преобразования, как и с алгебраическими выражениями. Можно следовательно раскрыть все скобки и представить всякую такую формулу в виде сумме элементарных произведений. Таким образом доказано, что для любой формулы существует ДНФ.

X&(!Y & Z)&(UvV) = X & (Yv!Z) & (UvV) = (XYvX!Z)(UvV)  = XYUv XYV v X!ZU v X!ZV

Для каждой формулы существует эквивалентная ей конъюнктивно нормальная форма.

X(X->Y) = X(!XvY) = X!X v XY = XY

XvY <-> XY

Заметим что для каждой формулы A существует не одна КНФ и ДНФ.
Произведя разными способами дистрибутивные операции, можно придти к различным нормальным формам.

Пункт 9.
Совершенная ДНФ. Совершенная КНФ.

Среди КНФ и ДНФ выделяется класс формул однозначно определяемых формулой A.

Формула А наызвается совершенной КНФ от высказывательных переменных x_1, x_2, ..., x_n
если она является конъюнкцией различных полных элементарных дизъюнкций от высказывательных перменных этой системы.
При этом порядок членов в элементарных дизъюнкциях не учитывается.

Например формула (x_1 | x_2 | !x_3) & (!x_1 | x_2 | x_3) & (x_1 | x_2 | x_3)
является СКНФ x_1, x_2, ..., x_n
так как КНФ является ТИ формулой тогла и только тогда, когда каждая входящая в нее элементарная дизъюнкция является ТИ формулой.
А последняя является ТИ формулой тогда и только тогда, когда она вместе с некоторой высказывательной переменной x_i содержит ее отрицание !x_i, то СКНФ не может быть ТИ формулой.

Определение СДНФ двойственно СКНФ. Формула Б называется СДНФ от высказывательных переменных x_1, x_2, ..., x_n
если она является дизъюнкцией различных полных элементарных конъюнкций от высказывательных перменных этой системы.
Другими словами Б - СДНФ, если Б равняется A*, для некоторой СКНФ формулы A.

Напомним что СДНФ A(x_1, x_2, ..., x_n) обладает следующими свойствами, в ней нет одинаковых слагаемых, ни одно слагаемое не содержит двух одинаковых множителей. Никакое слагаемое не содержит переменную вместе с ее отрицанием. В каждом слагаемом содержится в качестве множителя либо x_i, либо !x_i.

Условия 1-4 являеются необходимыми и достаточными для того, чтобы ДНФ была СДНФ.

Вместе с тем эти условия дают возможность высказать правила позволяющие выводить или приводить любую не ТЛ формулу к ДНФ.
Опишем эти правила.

Пусть дана произвольная формула A(x_1, x_2, ..., x_n) приведем к ДНФ форме B, затем если какое-нибудь слагаемое формулы B не содержит x_i, то заменим его на B&(x_i v !x_i) = B&x_i v B&!x_i.

Таким образом, мы можем изменить нашу ДНФ так, чтобы условие 4 было выполнено. Если в полученном выражении получаться одинаковые слагаемые, то удалив все, кроме одного из них, мы получим опять равносильное выражение. Если после этого в некотором слагаемом окажется по нескольку одинаковых множителей. То лишние множители можно удалить. Наконец, можно удалить те слагаемые которые содержат переменную вместе с ее отрицанием, так как слагаемые представляют собой тождественно ложное выражение. После этого получим СДНФ.

Заметим что нам нет необходимости знать заранее является ли формула ТЛ формулой или нет. Проделывая указанные операции мы это выясним после того, как удалим все слагаемые содержащие переменную вместе с ее отрицанием. Если формула А - ТЛ формула, то все слагаемые будут удалены и мы не получим СДНФ.

Можно доказать что каждая нетождественно истинная формула имеет единственную с точностью до порядка расположения множителей и слагаемых СКНФ. Правило приведения произвольной формулы к СКНФ аналогичны тем, которые мы описывали для нахождения СДНФ и выражаются в двойственных терминах.

$$A = X v Y (X v !Y) = X v XY v Y!Y = X = X & (Y|!Y) = XY | X!Y$$

Приведем формулу А к СКНФ, используя понятие двойственности.

$$A* = X&(Y(Xv!Y)) = X&YvX&X&!Y = X&Y v X&!Y$$

$$B* = X&Y v X&!Y$$

$$B = (XvY) & (Xv!Y)$$

Привести к СКНФ
$$(XvY)&(!Yv!Z)v(Xv!Y)&(YvZ)$$

Опишем Алгоритм получения для формулы A, заданной таблицей истинности эквивалентные ей СКНФ. Возьмем в таблице нули формулы А. По нулям построим полные элементарные дизъюнкции, которые на этих наборах принимают значение ноль, беря x_i, если x_i равняется нулю, если x_i равно единице и образуем их конъюнкцию, таким образом мы получим СКНФ. Эквивалентную формуле А.

x_1 x_2 x_3 A B
1 1 1 0 0
1 1 0 1 1
1 0 1 0 1
1 0 0 1 1
0 1 1 0 0
0 1 0 0 1
0 0 1 1 1
0 0 0 1 0

СКНФ
$$A_1 = (!x_1 v !x_2 v !x_3 ) & (!x_1 v x_2 v !x_3) & (x_1 v !x_2 & !x_3) & (x_1 & !x_2 & x_3)$$
СДНФ
$$A_2 = x_1 & x_2 & !x_3 & x_1 & !x_2 & !x_3 v !x_1 & !x_2 & x_3 v !x_1 & !x_2 & !x_3$$

Совершенно нормальные формы позволяют дать критерий равносильности двух произвольных формул А и Б. В самом деле каковы бы ни были формулы А и Б можно предполагать что они содержат одни и те же переменные. Иначе можно добавить
$B & (x_iv!x_i)$,
$B v (x_i&!x_i)$.

Таким образом, любые две формулы можно заменить равносильными им формулами содержащими одинаковые переменные. После этого эти формулы надо привести к СДНФ или СКНФ. Если А и Б равносильные формулы, то в силу единственности совершенно нормальных форм как ДНФ так и КНФ этих формул должны полностью совпадать. Таким образом сравнение совершенно нормальных форм формул А и Б решает вопрос об их равносильности. В заключении этого раздела отметим некоторые соотношения равносильности полезные для упрощения формул.

$$XvXY = X$$
$$X(XvY) = X$$
$$Xv!XY = XvY$$
$$!XvXY = !XvY$$
$$X(!XvY) = XYU$$
$$!X(XvY) = !XY$$

Эти соотношения можно сформулировать в виде правил следующим образом, если слагаемое некоторой суммы входит множителем в другое слагаемое, то второе слагаемое можно из суммы удалить.

Если множитель некоторого произведения входит слагаемым в другой множитель, то второй множитель можно удалить.

В каждом слагаемом можно удалить множитель, который равносилен отрицанию другого слагаемого.

В каждом множителе можно удалить слагаемое, которое равносильно отрицанию другого слагаемого.

1) $A = X v XY v YZ v !XX = X v !XZ v YZ = XvZvYZ = X v Z$
2) $B = (X v Y) (!X!YvZ)v!Zv(!XvY)(UvV)$

\subsection{Некоторые приложения теории алгебры логики.}

Релейно-контактные схемы.
Среди технических схем автоматизации значительное место занимают устройства релейно контактного действия.
Они широко используются в технике автоматического управления, в электронно-вычислительной технике и т.д.
Эти устройтсва их в общем случае называют переключательными схемами содержат сотни реле, полупроводников и электромагнитных элементов. Описание и контруирование таких схем
указал на возможность применения аппарата алгебры логики при исследовании релейно контактных схем. Использование алгебры логики в конструировании РКС оказалось возможным в связи с тем что каждой схеме можно поставить в соотвествие некоторую формулу алгебры логики и каждая формула алгебры логики реализуется с помощью некоторой схемы.

Это обстоятельство позволяет выявить возможности заданной схемы изучая соответсвующую формулу а упрощение схемы свести к упращению формулы. С другой стороны, до построения схемы можно описать с помощью формулы те функции, которые схема должна выполнять.

Рассмотрим как устанавливается связь между формулами алгебры логики и релейно-контактными схемами

Под переключательной схемой понимается некоторое изображение некоторого устройства состоящего из следующих элементов:

1) Переключателей, которыми могут быть механически действующие устройства(переключатели, переключающие ключи, кнопочные устройства и так далее)
2) Соединяющих их проводников
3) Входов в систему и выходов из нее(клем на которые подается электрическое напряжение)
4) Они называются полюсами схемы
5) Сопротивление, конденсаторы и так далее на схемах не изображаются. Переключательной схемой принимается в расчет только два состояния каждого переключателя, которые называются ``замкнутым'' и ``разомкнутым''.

Рассмотрим простейшую схему содержащую один переключатель P и один вход A и один выход B.

Переключателю P поставим в соответствие высказывание p:
переключатель P замкнут.

Если p истинно, то схема проводит ток. Если p ложно, то переключатель разомкнут и схема тока не проводит.
Если принять во внимание не смысл высказывания а только его значение, то можно считать что любому высказыванию может быть поставлено в соотвествие переключательная схема 1.

Конъюнкции двух высказываний p и q будет представлена двух полюсной схемой с последовательным соединением двух переключателей

Эта схема пропускает ток тогда и только тогда когда истинно p и q одновременно

Дизъюнкция изобразиться схемой: рис 3

Если высказывание !p есть отричацние высказывания p, то ТИ формула изобразиться схемой

Нарисовать схему для
XY v !X!Y

Дана схема, для нее формулу алгебры логики и упростить

XYZ v !XYZ v X!YZ v XY!Z

= yz(xv!x) v xz(!yvy) v xy(!zvz)
= yz v xz v xy = z(yvx) v xy

Из примера 2 следует что для некоторых РКС путем равносильных преобразований формулы алгебры логики можно получить РКС содержащую меньшее число переключателей, проблема решения этой задачи носит название проблемы минимизации.

Приведем проблемы минимизации.
Приведем пример построения РКС по заданным условиям с оценкой числа контактов.
Построить контактную схему для оценки результатов некоторого спортивного соревнования тремя судьями при следующих условиях
Судья засчитывающий результат нажимает имеющуюся в его распоряжении кнопку.
В случае если кнопки нажали не менее двух судей должна загореться лампочка, положительное решение судей принято простым большинством голосов. Ясно что работа нужной ркс описывается функцией буля трех переменных F(x, y, z), где переменное высказывание x, y, z означают - X - судья X голосовал за, .......


Таблица истинности функции F(x, y, z) имеет вид

X Y Z F
0 0 0 0
0 0 1 0
0 1 0 0
0 1 1 1
1 0 0 0
1 0 1 1
1 1 0 1
1 1 1 1

xyz v !xyz v x!yz v xy!z

Пункт второй
Решение логических задач методами алгебры логики.
Суть применения методов алгебры логики к решению логических задач состоит в том что имея конкретные условия логической задачистараются записать их в виде формулы алгебры логики. Дальнейшим путем равносильных преобразований упрощают полученную формулу. Простейший вид формулы как правило приводит к ответу на все вопросы.

Покажем на ряде конкретных примеров как использовать возможности алгебры логики для решения элементарных логических задач.

Пример четвертый
Пытаясь вспомнить победителей прошлогоднего турнира, пять бывших зрителей заявили:
Антон был вторым а Борис был пятым
Виктор был вторым а Денис третьим
Григорий был первым а Борис третьим
Антон был третьим а Евгений шестым
Виктор был третьим а Евгений Четвертым.

Впоследствие выяснилось что каждый зритель ошибся в одном из своих высказываний.
Каково было истинное распределение мест в турнире.
Решение.

Будем обозначать высказывания x_y, где X - первая буква имени участника, y - место которое он занял в турнире.
Так как в паре высказываний каждого зрителя одно истинно, а другое ложно, то будут истинны дизъюнкции этих высказываний.

A2 v Б5 = 1
В2 v Д3 = 1
Г1 v Б3 = 1
А3 v Е6 = 1
В3 v E4 = 1

(A2 v Б5) & (В2 v Д3) & (Г1 v Б3) & (А3 v E6) & (В3 v E4) = 1

Пример 5
Жили четыре мальчика. Альберт, Карл, Дидрих и Фридрих.
Фамилии друзей те же, что и имена только так что ни у кого из них имя и фамилия не были одинаковы.
Кроме того,
Фамилия Дидриха не была Альберт
Требуется определить фамилию каждого из мальчиков если известно, что имя мальчика, у котого фамилия фридрих, есть фамилия того мальчика, имя которого фамилия Карла.
Поставим в соотвествие каждому мальчику символ X с индексом Y, где X - имя, а Y - фамилия мальчика.
Тогда по условию ложны высказывания: Aa, Кк Фф, Дд, Фд

Есть мальчик такой, что истинна конъюнкция

Пример 6
По подозрению в совершении преступления задержали:
Брауна, Джона и Смита. Один из них был уважаемым в городе стариком.
Другой был малоизвестным чиновником, третий известным мошенником.
В процессе следствия старик говорил правду, мошенник лгал, а третий задержанный в одном случае говорил правду, а в другом ложь. Вот что они утверждали:

Б: Я совершил это, Джон не виноват
Д: Браун не виноват, преступление совершил Смит
С: Я не виноват, Виноват Браун.

Кто из них виноват, если преступник 1.
Решение

Обозначим буквами Б Д С, тогда утверждение высказанные задержанными модно записать в виде конъюнкции:
Б Д С | Б & !D | B & !C | C & !B | L
0 0 0 0 0 0 0
0 0 1 0 1 0 1
0 1 0 1 0 0 1
0 1 1 1 1 0 1
1 0 0 0 0 1 1
1 0 1 0 0 0 0
1 1 0 0 0 1 1
1 1 1 0 0 0 0

Формула L истинна в 5 из 8 занумерованных случая, формулу 4 сразу исключаем так как в ней истинны сразу две конъюнкции, а это противоречит условию задачи.

В случаях 2, 3, 5 оказываются истинны по два высказывания B и Д, Б и C, Д и С, что противоречит условию задачи.
Следовательно справедлив случай 7, то есть преступник Смит, он известный мошенник.

Отсюда ясно, что Джон уважаемый в городе старик, а Браун чиновник

Пункт 11 логическое следствие
Задача логики - дать принципы рассуждения наша цель получить критерий для решения механическим путем. Вопроса о том, можно ли некоторую цепь рассуждений основываясь на ее форме считать логичной, цель рассуждений представляет собой просто конечную последовательность высказываний приводимых в обоснование утверждения, что последнее высказывание в этой последовательности(заключение) может быть выведено из некоторых начальных высказываний. В обыденных условиях посылки вывода считаются истинными(на основании имещегося опыта, эксперимента или убеждения)

Если признать посылки вывода истинными, а принципы использованные в цепи рассуждений основанных на этих посылках правильными
то мы вынужденны рассматривать полученное заключение как истинное. В математической теории дело обстоит иначе. Там мы интересуемся исключительно заключениями(так называемыми теоремами теории), которые можно вывести из принятой начальной системы высказываний(так называемых аксиом теории) В соотвествии с правилами установленными в какой-либо логической системе. В частности в самой теории понятие истинности не играет никакой роли.

Вклад исчисления высказывания в теорию вывода заключается в следующем: оно дает критерий вместе с практическими формами его применения для решения того когда к заключительному предложению рассуждения следует приписать истинное значение 1, если каждой посылке приписывается значение 1. Этот критерий имеет форму определения.

Определение
Высказывание B есть логическое следствие A_1, А_2, ..., A_n |= B Если высказывание B истинно всякий раз, когда истинны высказывания A_1, A_2, ..., A_n.

Будем писать |=A Для обозначения того что формула A общезначима или тавтология.


Теорема 1
A |= B, тогда и только тогда когда формула B общезначима и тавтология

A |= B => |=A->B

По таблице для A->B имеем
A->B = 0, когда A = 1, B = 0.
На основании принятого допущения, такая комбинация истинностных значений не встречается. Следовательно A->B равно 1 тавтологий.

Пусть А->B общезначима, рассмотрим такое распределения истинностных значений, принимаемых простыми компонентами, что А получает значение 1.
Поскольку A->B равно 1, то из таблицы истинности для импликации следует, что B получает значение 1, то есть A вытекает(|=) B,что и требовалось доказать.


Теорема 2

Пусть A_1, A_2, ..., A_n |= B, тогда следующее утверждения равносильны:

1) A_1, A_2, ..., A_n |= B
2) A_1 & A_2 & ..., & A_n |= B
3) A_1 & A_2 & ..., & A_n -> B

Пусть B - логическое следствие формул A_1, A_2, ..., A_n.

Пусть A_1 & A_2 & ... & A_n -> B = 1, тогда A_1, A_2, ..., A_n = 1

Из 2 следует 3, смотри доказательство теоремы 1. Пусть A_1 & A_2 & ... & A_n -> B = 0
Такое невозможно так как B - логическое следствие A_1 & A_2 & ... & A_n

Из 3 следует 1.
Нас интересует A_1 & A_2 & ... & A_n = 1, то есть по определению логического следствия A_1, A_2, ..., A_n следует B.

-------------------------------------------------------------------------------------------------------------------------------

A_1 A_2, A_n-1, A_n следует(!=) B тогда и только тогда
A_1 A_2, A_n-1, A_n следует A_n влечет B

Доказать самостоятельно

Теорема 3
A_1 A_2, ..., A_n следует  (|=) A_i (i = i, n)

A_1, A_2, ..., A_n следует (|=) B_j (j = i, p)

B_1, ..., B_p |= C, то A_1, ..., A_n |= C



\section{Алгоритм распознавания логического следствия}
Пусть A_1, A_2, ..., A_n следует B,
1) Предположим противное, что рассуждение не является логическим следствием, то есть рассуждение не является логичным, то есть B = 0, когда все A_i = 1(i =\bar{1,n}).

2) Подберем переменные входящие в B таким образом чтобы B равнялось 0. Будем подбирать значения других переменных таким образом чтобы все A_i были равны 1.

3) Возможны 2 случая.
    а) Нам удалось подобрать переменные согласно пункту 2, значит предположение оказалось верным и рассуждение не логично.
    б) Нам не удалось подобрать переменные и мы получили противоречие, значит предположение было неверным и рассуждение логично.


Задача 1.

    A_1 : Я пойду домой или останусь здесь и выпью сока
    A_2 : Я не пойду домой
    Следовательно
    B : Я останусь здесь и выпью сока

    1) h V (s & d)
    !h |= s & d
    s  & d = 0 -> s = 0
                  d = 0

    h v s & d = 1   !h = 1 -> h = 0
    s & d = 0
    h = 1

    Рассуждение логично так как мы пришли к противоречию.


Задание 2
    A_1 Если я пойду завтра на первую пару то должен буду встать рано. А если я пойду вечером на дискотеку то лягу спать поздно.
    A_2 Если я лягу спать поздно, а встану рано то буду вынужден поспать лишь пять часов.


    A_3 я не в состоянии обойтись пятью часами сна.

    Следовательно я должен либо пропустить первую пару или не пойти на дискотеку.

    f - я пойду на первую пару
    g - я встану рано
    d - я пойду на дискотеку
    l - я лягу поздно
    s - я посплю 5 часов

    (f -> g) & (d -> l) , l & g -> s, !s != !f v !d

    Предположим что !f v !d = 1

    !f v !d = 0 Тогда и только тогда когда (f -> g) & (d->l) = 1 <=> d = 1 и e = 1
                                            f = 1
                                            d = 1

    !s = 1, s = 0
    l&q -> s = 1
    l = q = 1
    s = 0



    Задача 3
    Если Джонс не встречал этой ночью смита, то либо смит был убийцей, либо джонс лжет.
    Если смит не был убийцей то джонс не встречал смита этой ночью и убийство имело место после полуночи
    Если убийство было совершено после полуночи то либо смит был убийцей, либо джонс лжет.

    Следовательно смит был убийцей.

    p1 = джонс встречал этой ночью смита
    p2 = смит был убийцей
    p3 = джонс лжет
    p4 = убийство имело место после полуночи

    !p1 -> (p2 V p3),
    !p2 -> (!p1 & p4),
    p4 -> (p2 v p3)

        |= p2

    Предположим

    p2 = 0

    p2 = 0  !p1 -> (p2 v P3) = 1
               !p2 -> (!p1 & p4) = 1
               p4 -> (p2 v p3)  = 1

    !p1 -> (p2 v P3) = 1 <=>
        p1 v p2 v p3

    !p2 -> (!p1 & p4) <=>
        p2 v (!p1 & p4)

    p4 -> (p2 v p3)  = 1 <=>
        !p4 v p2 v p3 = 1





Правилами вывода матлогики называются правила по которым из исходных истинных формул Образуются новые истинные формулы
Пусть A_1, A_2, ..., A_n |= B
Правило вывода:
    1) Сокращение посылки modus ponens(Правило отделения).
    Пусть A истинно и A -> B = 1, тогда можно вывести B.
    $$ \frac{A, A->B}{B}$$
    2) Цепное правило
    $$ \frac{A->B, B->C}{A->C}$$
    3) Правило подстановки
    Пусть известно что \phi(x) = 1 и x = b, тогда \phi(b) = 1


Определение множества:
{A1, A_2, ..., A_N} непротиворечиво если A_1 & A_2 & ... & A_n = 1 по меньшей мере для одной комбинации приписываемых простым компонентам истинносных значений и такое же множество A_1, A_2, ..., A_n противоречиво если A_1 & A_2 & ... & A_n имеет значение ложь для всех комбинаций истиностных значений приписываемых простым компонентам

Определение:
Противоречие есть формула которая всегда ложна
A & !A

Теорема 4:
Множество высказываний
A_1 A_2, ..., A_N
Противоречиво если из него в качестве логического следствия можно вывести противоречия
Доказательство

Пусть для некоторой формулы B
A_1, A_2, ..., A_n |= B & !B, тогда
A1 & A_2 & ... A_n -> B & !B
И искомое заключение следует из истиннстной таблицы для импликации.
Противоречия играют важную роль в методе косвенного доказательства. Называемое также доказательством от противного.
Основой этого вида доказательств служит следующий результат:
если в качестве логического следствия из A_1 & A_2 & ... A_n и !B можно вывести противоречие.

Доказательство:
Пусть для некоторой формулы C

A1, A2, ..., AN, !B |=> C & !C тогда
A1, ..., An |= !B -> C & !C
Рассмотрим теперь такое распределение истинностных значений, приписываемых данным простым компонентам, что каждая
A_i принимает значение 1, тогда формула примет значение 1.
Этот факт и то что C&!C = Л влечет за собой



Логика предикатов.
Определение предиката
Для установления логических связей между свойствами элементов некоторого множества алгебры высказываний не достаточно.
Рассмотрим следующее предложение: всякая дифференцируемая функция является непрерывной
Функция $x^2 + x + 3$ является дифференцируемой
Функция $x^2 +x + 3$ является непрерывной

Существует определенная логическая связь между этими предложениями, но ввиду бедности языка алгебры высказываний выразить ее алгебры высказываний невозможно. Более того сами предложения невозможно записать на языке алгебры высказываний. Значительно большими возможностями обладает алгебра предикатов, в которую как часть входит алгебра высказываний.

\subsubsection{Определение(1)}
Одноместным предикатом $P(x)$ называется всякая функция одного переменного, в которой аргумент x пробегает значени из некоторого множества $M$. А функция при этом принимает одно из двух значений $0$ или $1$.

Множество $M$, на котором задан предикат называется областью определения предиката.

$I_P$ содержится в $M$
На котором предикат принимает только истинные значения называется областью истинности предиката $P(x)$

Предикат $P$ называется тождественно истинным или тождественно ложным если $I_P = M$ ($I_P=\empty$)

\subsubsection{Определение(2)}

N местным предикатом на множетсве называется функция
Имеющая тип $M^n$ $\rightarrow$ \{ $0$, $1$ \}

Где аргументом является вектор длинны m, с компонентами из множества M, а значением 0 или 1
Множество M будем называть предметным множеством.

Предикаты будем обозначать большими буквами латинского алфавита
$P$, $Q$, $R$, $Z$

$x$, $y$, $z$ - предметные переменные.
При $n$ равном единице предикат $P(x)$ называют свойством.
При n равном двойке называют отношением.

Операции над предикатами
Пусть на одноместных предикатах. $P(x)$, $Q(x)$

Введены операции
$$P(X) v Q(X)$$ - $x$ - четное или $x$ - простое
$$P(X) & Q(X)$$
$$P(X) \rightarrow Q(X)$$
$$P(X) == Q(X)$$
$$!Q(x)$$

Пусть $P(X)$ - $x$ - четное число,
      $Q(x)$ - $x$ - простое число

Операции ``$v$'' ``$&$'' ``$\rightarrow$'' ``$!$'' вводятся для предикатов аналогично операциям над высказываниями
И логические значения предикатных формул без труда определяются после подстановки конкретных значений
из предметных множеств.

Особняком стоят операции навешивания кванторов.
Для любого x P(x)
Будем обозначать таким образом высказывания, которые истинны тогда и только тогда, когда P(x) равно 1 для любого X, то есть предикат P(x) принимает значение истина для всех X из предметной области
Для люого x P(x) - высказывание

пусть M=N
Для любого x P(x) = 0
Для любого x Q(x) = 0

Для любого P(x) v Q(x) = 0

R(x) => x < 1
Для любого !R(x) = 1

Существует x P(x)
будем обозначать таким образом высказывание которое ложно тогда и только тогда когда P(x) ложно при всех x из предметного множества M,
т.е. P(x) = 0 для всех x принадлежащих M.


Пример:
P(x), Q(x), R(x).

Существует x P(x)=1
Существует x Q(x)=1
Существует x R(x)=0

Существует x (P(x) или Q(x)) = 1

Операция навешевания квантора  на переменную называется связыванием переменной и понижает местность предиката на единицу.
P(x) x_1, x_2, ..., x_n. - n+1 местный предикат

Для любого x P(x) - n метсные предикаты
Существует x P(x)

x - связанные переменные.
x_1, x_2, ..., x_n - свободные переменные.

Символом для любого x P(x) x_1, x_2, ..., x_n - обозначется n местные предикат зависящий от x_1, x_2, .., x_n  и не зависит от x

Он принимает значение 1 для тех и только для тех векторов a1 a2 ... an, для которох одноместный предикат P(x) A_1 ... A_n явялется тождественно истинным на M

I_P = M

Символом сущевтует x P(x) x1 ... xn называется n местный предикат P который зависит от x_1, ... x_n и не зависит от x

Он принимает значение 0 для тех векторов a1 a2 ... an из M для которых предикат P(x) a1, ... an тождественно ложный на M.




Пример
Пусть M - множество людей. Рассмотрим двуместный предикат A(x, y) => x обожает y

Для люого X Для любого Y A(x, y) = все обожают друг друга.
... = Существует человек обожающий другого или себя.
Для любого X Сущевтует Y A(x, y) = все кого-нибудь обожает.
... = Существует человек которого обожаю все.
= Каждого человека кто-нибудь обожает
Существует X Для любого Y A(x, y) = Существует человек который обожает всех.

Говорят что предикат P(x) является следствием предиката Q(x), если
I_Q содержится в I_P и предикаты P(x) и Q(x).

Говорят что предикаты равносильны если I_Q и I_P совпадают.
Формулы логики предикатов

В логике предикатов воспользуемся следующей символикой.
1) Символы p, q, r - переменные высказывания, принимающие два значения 1 или 0.
2) Предметные переменные x, y, z и т.д. которые пробегают значение из некоторого множества M; x^0 y^0 z^0 предметные константы. Т.е. некоторые значения некоторых переменных.
3) P(.) Q(.) - одноместные предикатные переменные R(.,., ,.) - n местная предикатная переменная

S^k - к местная предикатная переменная.

P^0(.) Q^0(.) символы постоянных предикатов

символы.
V & !

символы кванторных операций


вспомогательные символы
() и запятые.

Определение формулы логики предикатов.

1) Каждое высказывание как переменное так и постоянное является элементарной формулой.
2) Если P - символ предиката а x_1 x_n - символы предметного переменные или константы
То P(x_1, ..., x_n) - есть формула.

Такая формула тоже называетс яэлементарной. В ней предментные переменные являются свободными не связанные кванторами.
Если A и B - формулы, то слова A v B, A & B, A -> B, !A - есть формулы

Если A(x) формула в которую переменная x входит свободно то слова для любого x и существует x являются формулами, причем предметная переменная входит в них связанно.

Никаких других формул нет. Например:

Если P(x) Q(x, y) одноместный и двуместный предикаты а q, r переменные высказывания, то формулами будут слова:
q, P(x), P(x) & Q(x, y), для любого x P(x) -> существует x Q(x, y).

Из определения логики алгебры логики всякая формула алгебры высказываний является формулой логики предикатов.


Значение формулы логики предикатов.
О логическом значении формулы логики предикатов можно говорить лишь тогда, когда задано множество M, на котором определены входящие в эту формулу предикаты.

Логическое значение формулы логики предикатов зависит от значений трех видов переменных.
1) Значений входящих в формулу переменных высказываний.
2) Значений свобоных переменных на множестве M
3) Значений предикатных символов.

При конкретных значениях каждого из трех видов переменных формула логики предикатов становится высказыванием.
Имеющим истинное или ложное значение.

В качестве примера рассмотрим формулу:
Существует Y для любого Z P(x, y) -> P(y, z) в которой двуместный предикат P(x, y) определен на множестве MxM где M = { 0, 1, 2, ... N}
В формулу 1 входит переменный предикат P(x, y), предметные переменные x, y, z. Две из которых y, z, связаны кванторами а x свободная.

Возьмем за конкретное значение P(x, y) => x < y

А свободной переменной x = 5
Тогда при значениях y < x_0  = 5
P^0(x_0, y) принимает значение ложь и P(x, y) -> P(y, z) принимает значение истина, то есть высказывание существует y для любого Z
(P^0(x_0,y)->P^0(y,z)) имеет значение истина

Понятие модели.

Определение
Моделью M называется множество M с заданными на нем предикатами.
P_1^k_1 - с местностью 1
P_n^k_n - с местностью k

M = <M, P_1^k_1, ..., p_n^k_n>

Основными предикатами модели M
Множество дзета = P_1^k_1, ..., p_n^k_n> сигнатура модели

Множество <k_1, ..., k_n> типом модели

Для общности рассуждений считаем моделью считаем пустоем множество с системой нуль местных предикатов на нем.

M = <N_0, E^2, S^3, P^3>
Где N_0 = {0, 1, ...}

E(x, y) => x == y

S(x, y, z) => x + y == z

P (x, y, z) => x*y == z
 Тип <2, 3, 3>

 Имеется три метода определения нуля

 1) Для любого y S(x, y, y)
 2) E(x, 0)
 3) Для любого y P(x, y, 0)

 S(x, x, x)

 Определение:

 Множество всех моделей с одной и той же сигнатурой дзета называется классом модели сигнатуры Дзета и обозначается K_{дзета}

 Определение формулы модели М совпадается с определением формулы логики предикатов за исключением того что множество предикатных символов заменяется на сигнатуры модели M.

 A(x) == Существует y P(x, y, y) И S(x, y, y)
 = 1 когда x = 0.
 P(x, y, y) = 1 { когда x = 1 и y любое } или {y = 0, x любое}
 S(x, y, y) = 1 { x = 0, y любое }

 Существует x для любого y (!E(x, y)) => Существует Z S()
 Существует x для любого y x == y или Существует Z x + y == z
 Существует x для любого y Существует z x == y или x + y == z


 Для любого X СУществует y P(y * y, x)
 Для любого X СУществует y y * y = x

 Q(x, y) = x <= y

 Существует X Для любого Y Q(x, y) = 1 В качестве X берем 0.

 Определение
 Если для некоторых переменных a1, a2, ..., an основного множества модели M сигнатуры Дзета
 Значение формулы A(a1, ... an) = 1, то формула A называется выполнимой на модели M.

 Теорема 1. Формула для любого x A(x)
 вытекает A^k+1(x, y), где y не входит в A(x) является общезначимой.

 Здесь A(y, x1 ... xk) где y, x1, ... xn - свободные перменные, а x - связанная.

 Доказательство
 Пусть М множество, А(х) - одноместный предикат, тогда для любого x A(x) -> A(y) есть одноместный предикат, зависящий от переменной y.
 Где y - свободная переменная.

 Предположим что формула Для любого X A(x) -> A(y) = 0 при нектором значении a переменной y.
 Тогда для любого x A(x) = 1
 Следовательно при всех значениях x из M имеет A(x) = 1, в частности A(a) = 1. Получаем противоречие с равенством A(y) = 0.
 Это противоречие доказывает, что формула для любого x A(x) -> A(y) истинна в любой модели M, сигнатура которой содержит одноместный предикат.


 Теорема 2.
 Формула A(y) -> Существует x A(x) общезначима если переменная y не входит в формулу A(x)

 Доказательство:
 Согласно теореме 1, формула для любого x !A(x) -> !A(y) общезначима,
  но формула Для любого x !A(x)v!A(y)
  = Существует x A(x) v !A(y)
  = !A(y) v Существует x A(x)
  = A(y) => Существует x A (x)


  <N, Q(x, y) => x < y> Покажем что формула Для любого x существует y Q(x, y)  = 1
  , но Cуществует y что x < y = 0

  A -> B = 0.
Пример 1.
Если натуральное число l делится на 12, то оно делится на 3. Поэтому здесь делимость на 12 является достаточным условием для делимости числа l на 3.
А делимость числа l на 3 является необходимым условием для делимости числа l на 12 в то же время обратная теорема если число l делится на 3 то оно делится на 13 неверна. Поэтому делимость числа l на 3 не является достаточным условием делимости числа l на 12. А делимость числа l на 12 не является необходимым условием делимости числа l на 3.
Пример 2.
% В описанном четырехуголнике суммы противоположных углов
В описанном четырехугольнике суммы длин противоположных сторон равны между собой, то в этот четырехугольник можно вписать окружность.

Обе они истинны и следовательно здесь можно употребить логическую связку необходимо и достаточно.
Для того чтобы в четырехугольник можно было вписать окружность необходимо и достаточно чтобы сумма длинн его противолежащих сторон были равны между собой.

5) Доказательство методом от противного. Обычно проводится по схеме:
1) предполагается что теорема: для любого x из E  P(x)->Q(x) не верна

Значит существует такой объект x что P(x) истинна а Q(x) ложно

Если из этих предположений рассуждения приходят к противоречию, то делают вывод о том что исходное предположение неверно, а верна теорема 1. Покажем что такой подход дает доказательство истинности теоремы 1. Действительно предположение о том что теорема 1 несправедлива. Означает истинность вот этой формулы.

Для любого X принадлежит E (P(x) & !Q(x))

Противоречивое утверждение которое получается из допущения этого предположения C & !C, таким образом схема доказательства от противного сводится к доказательству истинности формулы. Для любого x принадлежащего E (P(x) -> Q(x)) -> C & !C = для любого x из E (P(x) -> Q(x))v(C & !C) = для любого x из E (P(x) -> Q(x)).


Аксиоматические теории
Параграф 1 Основные понятия
В АВ и в исчислении высказываний в использовании таблиц истинности давало достаточно эффективный способ решения вопроса о том является ли данная формулы тавтологией.

Ситуация принципиально меняется при переходе к логике предикатов. Здесь нет эффективного способо позволяющего для каждой формулы дать ответ на вопрос является ли она общезначимой. То есть тождественно истинной или тождественно ложной. в связи с этим в математических теориях использующих понятие предиката необходим становится аксиоматический подход. Другие доводы в его пользу:
Аксиоматический метод базируется на простых отношениях между символами и выражениями точных формальных языков и использует достаточно простые арифметические методы. Аксиоматическая теория это совокупность всех теорем доказываемых исходя из данной системы аксиом. Аксиоматические теории делятся на формальные и неформальные неформальные аксиоматические теории наполнены теоретико множественным содержанием, понятие выводимости в них довольно расплывчато и в значительной степени опирается на здравый смысл. Формальная аксиоматическая теория считается определенной если выполнены следующие условия.

Задан язык теории (некоторое не более чем счетное число символов, называемое алфовитом теории, конечные последовательности символов алфавита назовем выражениями)

Определено понятие формулы в этой теории. то есть подмножество выражений. Выделено некоторое множество формул называемых аксиомами. Определены правила вывода в этой теории(то есть некоторое отношение ро1, ро2, .... между формулами).

Среди формальных аксиоматических теории выделяют теории первого порядка:

Они отличаются от теорий высшего порядка тем что не допускают в своем изложении предикаты которые имеют в качестве возможных значений своих аргументов другие предикаты и функции, кроме того они не допускают кванторные операции по предикатам или функциям. Теории первого порядка достаточно для выражения большинства математических теорий. Такие математические теории иногда называют элементарными теориями. Аксиомы теории первого порядка разбиваются на два класса, логические и спцеиальные.

Логические аксиомы:
Каковы бы ни были формулы A, B, C теории T следующии формулы являются логическими аксиомами теории T.

1) A -> (B -> A)
2) (A -> (B -> C))->((A->B)->(A->C))
3) (!B -> !A) -> ((!B -> A)-> B)
4) Для любого x_i A(x_i)-> t
Где A(x_i) есть формула теории T. t - предметная переменная или переменная константа. t может совпадать с x_i

5)Для любого x_i (A -> B)-> (A-> для любого x_i B)
Если x_i не входит свободно в формулу A.

Замечание: ранее было построено классическое исчисление высказываний содержащее 11 аксиом. Однако может быть построено исчисление высказываний с меньшим числом аксиом. В частности с логическими аксиомами 1-3. Специальные аксиомы не могут быть сформулированы в общем случае так как они меняются от теории к теории. Теории первого порядка не содержащая специальных аксиом представляет собой чисто логическую теорию, она носит название исчисление предикатов первого порядка.

Правила вывода:
В исчислении высказываний будем пользоваться понятиями вывода из совокупности формул H высказывание входящее в H будем называть допущениями или посылками. Если последним высказыванием в выводе H стоит A то будем говоорить что предложение A выводимо из H и записывать: H |= A

В частном случае если H = \empty, будем записывать |= A

В число правил теории первого порядка включаются два правила:
1) Правило заключения или модус поненс
|= A -> B |=B
2) Правило связывание квантором всеобщности |= A |= для любого xi A
Доказательство в теории,
Доказательство в широком смысле этого слова есть способ обоснования истинности некоторого суждения, степень убедительности доказательства решающим образом зависит от средств используемых для обоснования истинностей.
Так в точных науках выработаны определенные требования к эксперименту, при которых факт полученный в результате эксперимента может считаться доказанным. В математике для которой характерен аксиоматический метод определяется взглядом на аксиоматическую теорию. Слово теория понимается в определенном специальном смысле. Термин теория применяют по отношению к двум множествам высказываний одно из которых есть собственное подмножество другого. Большее объемлющее множество высказываний определяет предметную область теории. Элементы же меньшего множества высказываний это высказывания теории которые считаются в ней истинными или доказуемыми или теоремами.

Они определяются как высказывания выводимые чисто логическим путем из некоторых зараенее выбранных и фиксируемых высказываний, называемых аксиомами.

В аксиоматической теории понятию истинности нет места - понятие истинного высказвания имеет смысл лишь в связи с возможными приложениями теории.

Доказательством или выводом называют конечную последовательность s1, s2, ..., s_n высказываний рассматриваемой теории, каждая из которых является аксиомой либо выводится из одного или более предыдущих высказываний этой последовательности по логическим правилам теории.

Определение 2: теоремой или доказуемым высказыванием называется высказывание являющееся последним высказыванием некоторого доказательства. Ясно что любая аксиома является теоремой причем ее доказательство состоит из одного шага. Вывод высказывания c из пустого множества посылок есть очевидно доказательство высказывания c.

Определение 3: формула A называется следствием множества формул \gamma тогда и только тогда когда существует такая последовательность формул A_1, A_2, ..., A_n что A_n = a и все A_i i = 1...n либо аксиомы теории Т, либо формулы из множества \gamma, либо непосредственное следствие из предыдущих формул. Эта последовательность называется выводом формулы A из множества гипотиз \gamma.
\gamma |= A.

Свойства понятия выводимости:
Пуст \gamma - произвольное множество формул, A, B, C - произвольные формулы.
1) Из \gamma, A выводится A. Вывод формулы A из системы \gamma состоит из одной формулы A.
2) Если Из \gamma, A, B Выводимо C.
То \gamma B, A тоже выводимо C.

если из \gamma выводится B то из \gamma A выводится B

если из \gamma выводится B, \gamma выводится A
из B, A выводится С.

Если из gamma выводится A, B.
из gamma A,
то из gamma выводится B


В качестве аксиоматической теории рассматривалось исчисление высказываний и исчисление предикатов, где четко задавался алфавит, формулы, аксиомы, правила вывода.

3 Параграф.
Полнота и непротиворечивость исчисления высказываний. Независимость системы аксиом: теория T называется непротиворечивой если она содержит такое высказывание S, что S и !S одновременно являются теоремами.
В противном случает теория T называтся непротиворечивой.

Для аксиоматических теорий вопрос об их непротиворечивости во многих случаях решают с помощью модели. Моделью теории называется интерпретация языка этой теории.

Проще говоря, имея некоторую теорию T, мы приписываем первоначальным понятиям этой теории некоторый новый смысл. Если некоторая совокупность предметов и отношений между ними выбранных в качестве значений первоначальных понятий аксиоматической теории то есть в качетсве ее интерпретации удовлетворяет всем аксиомам теории то она называется можелью данной аксиоматической теории. Так ранее мы определяли алгебру буля и получили две ее модели: Алгебру логики и Алгебру множеств. В самом деле, если теория T противоречива, то каждая ее модель содержит противоречие, так как пара противоречащих друг другу теорем теории переводится в два противоречащих друг другу высказывания о модели значит теория непротиворечива если для нее можно указать свободную от противоречий модель. Если для теории T можно найти такую интерпретацию, что ее интерпретацией является конечное множество, то вопрос об отсутствии противоречий в интерпретации решается прямым рассмотрением конечного множества, однако часто доказательства непротиворечивости модели требуют сложных рассуждений. В частности это бывает в случае когда теория T имеет только бесконечные модели. Непротиворечивость геометрии евклида и непротиворечивость теории действительных чисел до сих пор не доказана. В предположении что непротиворечивость некоторой теории доказана или считается что может быть доказана имеет смысл поставить проблему полноты теории в узком и широком смысле. Теорема: всякое исчисление предикатов первого порядка T - непротиворечиво. Теория T называется абсолютно полной или полной в широком смысле если для любого высказывания S этой теории или S или !S теорема.

Теорема:
исчисление высказываний полно в узком смысле и в широком смысле.

Аксиоматическая теория называется полной в узком смысле если добавление к ее аксиомам любого недоказуемого в ней утверждения с сохранением в ней всех правил вывода приводит к противоречивой теории. Теория которая является одновременно непротиворечивой и полной в широком смысле будет максимальной в отношении непротиворечивости в том смысле что добавление к такой теории в качестве аксиомы любого предложения которое можно сформулировать в этой теории, но не являющейся ее теоремой приводит к противоречивой теории. Заметим что для многих математических теорий наличие обоих качеств одновременно не имеет смысла.

Проблема разрешимости логики предикатов. Простейшим примером проблемы разрешимости является проблема разрешимости алгебры логики. Она состоит в отыскании алгоритма, позволяющего для каждой формулы алгебры логики установить является она ТИ формулой или выполнимой.

Новая глава называется элементы теории алгоритмов. Машины тьюринга.unit

Интуитивное понятие алгоритма.

1.1 Алгоритмы разделяются на технологические, управляющие и информационно-вычислительные

технологические алгоритмы изменяют физико химические параметры исходного объекта:
Рецепт приготовления пищи, технологические производственные цепочки, инструкции по применению товаров бытовой химии и т.д.

Управляющие алгоритмы переводят объекты из одного состояния в другое без изменения физических свойств самого объекта.

Например правила действия в метро, правила пользования телефонным автоматом и т.д.

информационно вычислительные алгоритмы в качестве объекта преобразования используют символьные или числовые данные. Они как правило реализуются в компьютерных технологиях. К ним относятся классические вычислительные алгоритмы. Алгоритм евклида позволяет находить gcd. Алгоритм Решето Эратосфена.

Абстрактное понятие алгоритма.

Понятие алгориттма относится к фундаментальлным понятиям современной математики.

Уместно провести аналогию понятия алгоритма с понятием множества. Оба этих понятия не имеют строгого определения. Они являются первоначальными определениями теории в их понимании не возникает существенных разногласий. Таким понятием в теории алгоритмов является само понятие алгоритма. Под алгоритмом в интуитивном смысле принято понимать правила сформулирование на некотором языке и определяющее процесс переработки допустимых исходных данных в искомые результаты. Допустимые исходные данные для этого правила предложения языка исходных данных. В символьной(в частном случае в числовой форме).

Иначе говоря алгоритм или эффективная процедура это механическое правило или автоматический метод или программа для выполнения некоторых вычислительных операций.
Приведем еще примеры операций для которых лекго указать алгоритмы

1) Дифференцирование многочлена
2) Деление многочлена на многочлен
3) Для двух данных натуральных чисел x y решить является ли x кратным y.

Общее свойства интуитивно понимаемого алгоритма

1) Алгоритм предполагает наличие исходных данных и приводит к получению определенного результата. Например для алгоритма сложения столбиком исходными данными является пара чисел. А результатом число.

2) дискретность алгоритм представляется собой правила указывающее цепочку действий от исходных данных к результату.
Алгоритм реализуется как последовательность довольно простых шагов. На каждом шаге в качестве исходных данных берутся результаты предыдущего шага.

3) Массовость алгоритм применим к большому числу однотипных задач, путем выбора исходных данных из некоторого потенциально бесконечного множества. Однако термин массовость весьма расплывчат, это подтвержадает парадокс Булида, часто называемый парадоксом Кучи.

Суть в следующем зададим себе вопрос Один камень - куча? В конце придем к выводу что либо куч не существует, либо существует такое количество камней, увеличение которого на единицу приводит к получению кучи из некучи. И то и другое - противоречие фактам и является следствием расплывчатости понятия кучи. Какой же смысл вкладывать в понятие массовость. Нужно считать что для каждого алгоритма существует класс объекта и все они допустимы в качестве исходных данных. Другими словами массовость алгоритма - это допустимость всех объектов определенного класса а вовсе не допустимость какого-то количества объектов. А вот конечно или бесконечно количество допустиых объектов это уже свойство класса.

4) детерминированность - очередность шагов алгоритма и действий на каждом шаге однозначно определяется результатами полученными на предыдущих шагах или исходными данными.

5) результативность - свойство алгоритма означает возможность получения результата после конечного числа шагов. Может быть два исхода выполнения алгоритма

а) процесс вычисления длится бесконечно долго т.е. алгоритм не применим к исходным данным.
б) процесс вычисления завершается за определенное число шагов. Т.е. алгоритм применим к исходным данным.

Понятность - алгоритм должен быть понятен для исполнителя, исполнитель может этот алгоритм знать, если это человек, или может быть так дрессирован если это животное или может быть так устроен чтобы его выполнять если это машина.

Две основные проблемы теории алгоритмов

1) Конструирование и применение алгоритмов для решения конкретных классов задач. Здесь достаточно понимания алгоритма в интуитивном смысле.
2) Интуитивное понятие алгоритма хотя и не строгое но настолько ясное что почти всегда можно определить является ли данный процесс алгоритмом.

Поэтому удовлетворительным доказательством существования алгоритма является описание фактического процесса решения какой-либо задачи.
Иначе говоря для доказательства существования алгоритма решения некоторой задачи достаточно описать этот алгоритм.

Вторая проблема возникает из того что в ряде случаев поиски алгоритма обеспечивающее решение конкретного вида задач оказались безуспешного. Например для проблемы установления общезначимости логики предикатов. Была высказана гипотеза, что существует алгоритмически неразрешимые проблемы, но чтобы подтвердить эту гипотезу интуитивное понятие алгоритма недостаточно. Доказательство существования алгоритмически неразрешимых проьлем возможно лишь на базе строгого формального определения алгоритма. Однако как уже говорилось выше, в общем случае невозможно дать формальное определения алгоритма. Методология решения второй проблемы основывается на переходе к более узкому уточнению понятия самого алгоритма. Фактически понятие алгоритма заменяется другим более узким понятием вычислимости функции. Речь идет о существовании эффективной процедуры вычисления функции. В целях далльнешего сужения и конкретизации проблемы рассматриваются не произвольные а так называемы арифметические функции. Областью задания и областью значения служат подмножества неотрицательных целых чисел. Заметим что понятия целой функции также как и понятие алгоритма является интуитивным. Домашенее задание - опишите словесно алгоритмы, изобразите их блок схемой и покажите что построенным алгоримам присущи все описанные выше свойства:

А) Вычисление суммы и частного столбиком.
b) Произведенеи двух матриц.
c) Вычисление обратной матрицы
d) Нахождение матрицы сильной связности для ориентированного графа.

Интуитивно вычислимые функции:

Будем дальше рассматривать алгоритмы которые вычисляют функции имеющие тип N ^ k _ 0 -> N_0
число k указывает на размерность аргумента. Алгоритмы вычисляющие такие функции называются арифметическими. Очевидно арифметические функции необязательно являются всюду определенными например f1 (x1, x2) = x1 - x2;
f2 = x1 / x2

f3  = x1 < x2

являтся частичными. Будем понимать под термином функция такие частичные функции.

Всюду определенные арифметические функции будем называть тотальными. f4 (x1, x2) x1 + x2, f5 x1 * x2, f6 x1 ^ x2

Пусть известно что алгоритм М вычисляющий функции f(x1, x2, ..., x_k) Это означает что для любого вектора A1, A2, ... Ak принадлежащего N_0^k имеет место следубщее

1) Если a_1, a_2, ... a_k принадлежит D(f), то алгоритм М начав вычисление с вектора a1 a2 ... ak то есть подав его на вход. в результате даст значение равное f(a1 a2 ... ak)

2) Если a_2, a_2, ... a_k не принадлежит к D(f), то алгоритм M не применим для данного вектора, поскольку определение интуитивно функция для которой существует вычисляющий ее алгоритм называется интуитивно вычислимой функцией или эффективно вычислимой. Однако на ряду с вычислимыми арифметическими функциями существует и не вычислимые функции.

f(x) =  1 x принадлежит A_пи
        0 x приндлежит A_пи

        Где A_пи - множество состоящее из натуральных чисел которое является цепочками десятичной записи числа пи. так как число pi является бесконечной непериодической. В случае когда аргумент не принадлежит поиск будет продолжаться бесконечно.

Приведите другие примеры интуитивно не вычислимых функций

Подходы  к уточнению понятия алгоритма, в интуитивном определении алгоритма использовались понятия которые сами нуждаются в уточнении: так как это определение не является формальным, то не возможно решить вопрос о том что для решения некоторой проблемы нельзя построить алгоритм. в теории алгоритмов для построения формальной модели алгоритма применяется другой подход - выбирается конечный набор исходных объектов которые объявляются элементарными и конечный набор способов построения из них новых объектов. Кроме того фиксируется набор элементарных шагов и организация памяти.После этого получается конкретная алгоритмическая модель. За краткую историю теории алгоритмов было предложено три основных математических уточнения понятия алгоритма(Эффективной вычислимости):


1) Рекурсивные функции - Черч, Клини.
2) Машина Тьюринга - Тьюринг, Пост
3) Нормальные алгоритмы Маркова.

Относительно трех подходов к уточнению понятия алгоритма вызывают два естественных взаимосвязанных вопроса.

Как сравнить подходы между собой.
Насколько хорошо характеризуют эти подходы неформальное понятие эффективной вычислимости.
Основной результат - каждая из вышеупомянутых уточнений понятия эффективной вычислимости (Алгоритма) приводит к одному и тому же классу вычислимых функций.

Так мы получаем простейший ответ на возможный из подходов. Исследование проблемы вычислимости частичных функций привело к фундаментальному открытию в математике 20 в. было строго доказано что класс вычислимых арифметических функций совпадает с классом частично рекурсивных функций. для всякой частично рекурсивной функции существует эффективная процедура позволяющая вычислять ее значение. Другими словами для нее может быть указан вычислительный алгоритм. Следовательно чтобы доказать вычислимость какой либо функции достаточно доказать что она является частично рекрсивной. Это и составляет содержание тезиса Черча и Клини. Суть методологии заложенной в тезисе Черча и Клини заключается в том что проблема существования алгоритма сводится к проблеме эффективной вычисломсти частичной функции, то есть к доказательству принадлежности этой функции к классу частично рекурсивных функций.


\section{Машина Тьюринга}
\subsection{}
1) Идея Тьюринга в 1936 году Алан Тьюринг опубликовал первую работу по проблемам абстрактных моделей вычислений в которой предложил свой подход к формальному определению вычислимости. Определение вычислимости по Тьюрингу основано на анализе осуществления алгоритма человеком располагающим ручкой и бумагой. Тьюринг рассматривает алгоритмы как последовательность двух вилов действий.

1) Запись или стирание одного символа.
2) Перенесения внимания с одного участка бумаги на другой.

На каждом шаге алгоритм определяет действие, которое будет совершено на следующем шаге. Это зависит только от символа на участке бумаги, который обозревается в данный момент глазом.

Текущего состояния мыслей человека. Чтобы обеспечить возможность реализации алгоритма мы предполагаем что это состояние полностью определяется алгоритмом и предысторией его работы. Оно может включать частичную запись того, что произошло до сих пор но не зависит ни от настроения, ни от сообразительности исполнителя алгоритма. Кроме того существует только конечное число различных состояний в которых может находится исполнитель. Состояние исполнителя может конечно изменяться в результате действия предпринятого на данном шаге. Тьюринг изобрел конечные машины, которые выполняют алгоритмы представленные таким образом. Как будет показано ниже для каждого алгоритма существует своя хоть и не единственная машина тьюринга.

\subsection{Устройство машины тьюринга}

Машина тьюринга это чисто математический объект при описании которого принято пользоваться механическим языком. Фундаментальное свойство машины тьюринга хранить и изменять неограниченное колическов информации. Существует множество различных способов описать такое свойство. Один из таких - ленточный автомат, позволяющий читать и записывать на ленту символы с единственным ограничением. Записывающий инструмент автомата может обозревать только одну ячейку ленты. устройство машины тьюринга составляют следующие понятия - лента разбитая на ячейки бесконечная в обе стороны.

1) При решении задач мы рассматриваем лишь конечный франмент ленты к которому справа и слева можно присоединять столько ячеек сколько необходимо для осуществления алгоритма.

2) Алфавит машины тбюринга. Непустое множество символов A = {s_0 s_1 ... s_m} которые часто называют ленточными или s символами. В каждой ячейке может поместиться не более одного символа, некоторые ячейки могут быть пустыми. Для определенности зафиксируем s символ и объявим его пустым. В каждой машине тьюринга используется конечное число s символов.

3) Читающая и записывающая головка перемещается вдоль ленты вправо и влево имеет внутренний конечный алфавит Q = {q0, q1, ... , q_r}, которые часто называют множеством внутренних состояний головки машины тьюринга.

Механизм работы машины тьюринга.

В каждый момент времени t головка машины тьюринга находять в состоянии q_i - воспринимает символ s_j на ленте. 
Головка машины тьюринга. Будем говорить машина тьюринга может выполнять одно из трех действий.

1) стирать s_j записать в эту же ячейку s_k, перейти в состояние q_l
Говорят что машина Тьюринга выполнила команду q_i s_j s_k q_l;
2) переместится на одну ячейку вправо и перейти в состояние q_l. Говорят что машина тьюринга выполнила команду q_i s_j R q_l

3) Vlevo
q_i, s_j, L, q_l.
Lubaya chetverka takogo vida nazivaetsya komandoy mashini tyuringa

Budem ponimat pod programmoy mashini tyuringa nepustoye mnojestvo komand takoe shto nikakie 2 razlichniye comandi ne coderzhat razlichnix simvolov


teper mi mozhem sformulirovat opredelenie mashini t'yuringa

Mashina t'uringa 

Q A P q gde Q - konechnoe nepustoe mnozhestvo sostoyani golovki mashini t'uringa 
A - konechniy alfavit lentochnix simvolov
P - konechnoe mnogestvo komand
q - nachal'noe sostoyanie mashini t'uringa

Do nachala vichisleniya mashina t'uringa doljna bit' snabjena lentoy na kotoroy napisana vhodyachsha gruppa simvolov
Chitayushzhaya golovka dolzhna obozrevat' specialnuyu nachalnuyu yacheyku 
Kak pravilo eto kraynyaya levaya nepustaya yacheyka, krome togo golovka machini t'uringa dolzhna nahodit'sya v nachalnom sostoyanii q.
Posle etogo machina t nachinaet vipolnyat komandi do teh por poka ne obnarujit otsutstvie komandi opredelyaushiy chto delat' dal'she drugimi slovami mashina t nahodyas' v sostoyanii q i obosrevaya simviol s_j ne budet soderjat' komandi nachinayushiesya s dvuh pervih simvolov. Takim obrazom tekushee sostoyanie mashini T polnost'u opisivaetsya sleduyushimi elementami:
1) Slovom v alfavite A napechatanom na lente
2) Sostoyaniem chitaeshuy zapisivayushey golovki q_i
3) Simvolom s_j kotoriy ona vidit

Rassmotrinie svoyastva pozvolyaut vvesti ponyatie configuracii mashini t'uringa
Pod configuraciey mashini t'uringa mojno prinyat' slovo P q_i s_j Q gde P, Q slova v alfavite mashini T.
s_j - simvol obozrevayemiy golovkoy T. q_i - tekushee sostoyanie mashini T. Esli v processe raboti mashina T pereydet ot configuracii Q k configuracii V zapisivayut U ->_t V
Esli configuraciya U takova chto net takoy configuracii V to configuraciya U nazivaetsya zakluchitel'noy.

Posledovatel'nost' configuracii U_0 -> _T U_1  -> _t ... -> _t U_r

nazivaetsya vichisleniem na mshine T.
Mashina t'uringa T yavlyaetsya determinirovannoy poskol'ku libo sushestvuet edinstvenniy perehod ot configuracii ot konfigurcii U_i -> _t U_i+1 libo konfiguraciya U_i yavlyaetsya zakluchitel'noy etot perehod odnoznachno opredelyaetsya mnozhestvom koandi T. Dalee budem rassmatrivat' tol'ko determinirovannnie mashini t'uringa.

Primeri mashin t'uringa i vichisleniy na nih.

Primer 1:

Create turing machine to calculate total aripmetic function f(x) => x + 1 in decimal system.
    0    1    2   3   4   5   6   7   8   9    L
q_o Rq0  Rq0  Rq0 Rq0 Rq0 Rq0 Rq0 Rq0 Rq0 Rq0  Lq1
q_1 1q2  2q2  3q2 4q2 5q2 6q2 7q2 8q2 9q2 0q2  1q2
q_2 Lq1  -    -   -   -   -   -   -   -   -    -  

Opredelim ishodniye dannie na lente napisano neotricatel'noye celoe chislo po odnomu razryadu v yacheyke.
Golovka obozrevayet samiy starshiy razryad chisla.
Samuyu levuu nepustuyu yacheyku.
Nam nuzhno poluchit' v kachestve zakluchitel'noy konfiguracii chislo nalente na 1 bol'shee dannoe.
Golovka mojet nahoditsya v lubom meste lenti.
Spisok komand dlya mashini udobno oformit v vide tablici.
Gde po vertikali priveden spisok sostoyaniy mashini t'uringa. 
Po gorizintali spisok simvolov vhodnogo alfavita.
V kletkah na peresechenii strok i stolbcov posledniye dva elementa - komandi mashini t'uringa T.
Pervaya dvoyaka komandi dani v zagolovkah strok i stolbcov tablici.
komentariy k tablice komand. V sostoyanii q0 mashina t'uringa ishet samiy mladshiy razryad dlya chego peremeshyaetsya vpravo po yacheykam.
soderzhashim cifri ishodnogo chisla poka ne obnaruzhit pustuyu yacheyku
zatem golovka sdvigaetsya na odin simvol vlevo obozrevayet iskomiy razryad. I perehodit v sostoyanie q1. V sostoyanii q1 mashina t'uringa zamenyaet cifru v mladshem razryade krome sluchaya kogda obozrevayemaya cifra ravna 9. devyatka v mladshem razryade zamenyaetsya na 0. V oboih sluchayah mashina t'uringa perehodit v sostoyanie q2. Esli v sostoyanii q2 golovka obozrevayet yacheyku c cifroy ot 1 do 9 tak kak na peresechenii strok b cnjk,wjd cnjbn ghxthr tckb ;t ujkjdrf dblbn 0 nj jyf cldbuftncz yf zxtqre dktdj b gtht[jlbn d cjcnjzybt q1.






Jxtdblyj xnj lfktt vfibyf gjdnjhbn jgbcfyyst dsit ltqcndbz gjrf yt jcnfyjdbncz. Pfvtnbv xnj d cjcnjzybb q1 vfibyf ,eltn j,jphtdfnm gecnjq cbvdjk. "nj ,eltn jpyfxfnm xnj bcxthgfy cnfhibq hfphzl xbckf b cktljdfntkmyj yflj pfvtybnm gecnjq cbvdjk yf tlbybwe 

Ghbvth hf,jns.

q03 -> 3 q0 _ -> q1 3 -> q24 
q09 -> 9q0 _ -> q19 -> q20 -> q100  -> q210

Ghbvth 2

Yfgbcfnm vfibye nm.hbyuf vtyz.oe. gthde. b gjcktlye. ,erde vtcnfvb
	 a  b   _
q_0  Rq1  Rq6 i - // Pagjvybv gthdsq cbvdjk sdvinemsya na yacheyku vpravo i pereydem v zavisimosti ot simvola v odno iz sostoyaniy q1 ili q6
q_1  Rq1 Rq1 Lq2  // Yfqltv rjytw ckjdf ecnfyjdbv ujkjdre yf gjcktlybq cbvdjk ckjd b gthtqltv d cjcnjzybt q2
q_2  -   aq3 -    // Tckb gjcktlybq cbvdjk a nj jcnfyjdrf, tckb byfxt nj pfvtybv tuj yf a b gthtqltv d cjcnjzybt q3 
q_3  Lq3 Lq3 Rq3  // Botv yfxfkj ckjdf b gtht[jlbv d cjcnjzybt q4
q_4  bq5 aq5  -   // pfvtybv cbdjk yf ghjnbdjgjkj;ysq b gthtqltv d cjcnjzybt q5
q_5  -   -   -    // Jcnfyjdrf
q_6  Rq6 Rq6 Lq7  // Ltqcndbt lkz cbvdjkf b analogichniye q1 gtht[jl d cjcnjzybt q7
q_7  bq3 -   -     // Ltqcndbt lkz cbvdjkf b fyfkjubxyst q2

Htitybt yf d[jlt ckjdj d fkafdbnt ab. Ujkjdrf j,jphtdftn zxtqre cjlth;foe. cfvsq ktdsq cbdjk ckjdf

q0 ab -> a q1 b ->  ab q1 _ -> aq2b -> aq3a -> q3aa -> q3 _ aa -> q4 aa -> q5 ba

Ljvfiytt pflfybt bab

Ghbvth 3.

Yfgbcfnm vfibye dsxbckz.oe. aeyrwb. f(x) = x _ x ult x - slovo v alfavite T

Htitytbt

	a    b    u    v   _
q0  uq1  vq3  -    -   -
q1  Rq1  Rq1  Rq1  Rq1  Rq2 // Yfqltv rjytw ckjdf cldbytvcz tot dghfdj jn gthdjuj dcnhtnbditujcz gecnjuj cbvdjkf b gthtqltv d cjcnjzybt q2
q2  Rq2  Rq2  -    -    aq5 // Gjrf yt dcnhtnbncz gecnjq cbvdjk ldb;tvcz dghfdj gecnjq cbvdjk pfvtyztv yf a b gtht[jlbv d cjcnjzybt q5
q3  Rq3  Rq3  Rq3  Rq3  Rq4  // Fyfkju q1 lkz cbvdjkf b 
q4 Rq4   Rq4  -    -    Rq5  // Fyfkju q2 lkz cbvdjkf b
q5 Lq5   Lq5  aq6  bq6 Lq5 // Djpdhfoftvcz d jnvtxtyyjt cbvdjkfvb u vtcnj pfvtyztv yf bc[jlyst a bkb b, gtht[jlbv d cjcnjzybt q6
q6 Rq0   Rq0 -     -    -   // Ntreobq cbvdjk j,hf,jnfy cldbuftvcz yf cbvdjk dghfdj, xnj,s ghjljk;bnm bkb pfdthibnm rjgbhjdfybt gtht[jlbv d cjcnjzybt q0

Ghb htitybb 'njq pflfxb yfv gjnht,etncz ddtcnb ghjvt;enjxysq fkafdbn bp lde[ cbvdjkjd u b v lkz njuj xnj,s pfgjvybnm rjgbhetve. yf lfyyjv ghj[jlt zxtqre vs vj;tv ljgjkyznm d[jlyjq fkafdbn cke;t,ysvb cbvdjkfvb rjulf 'nj elj,yj jlyfrj d pfrk.xbntkmyjq rjyabuehfwbb yf ktynt jcnf.ncz njkmrj cbvdjks d[jlyjuj fkafdbnf.

Ljvfiytt pflfybt yfgbcfnm d fkafdbnt a b vfibye nm.hbyuf j,kflf.oe. cktle.obvb cdjqcndfvb 
a) vfibyf bvtttn jlyj cjcnjzybt 1 rjvfyle b ghbvtybvj r k.,jve ckjde
b) vfibyf bvttn ldt rjvfyls ytghbvtybvf yb r jlyjve ckjde pjyf tt hf,jns ,tcrjytxyf

Yfgbcfnm rjvfyls dsgjkyz.obt cktle.obt ltqcndbz yfl ckjdfvb bp fkafdbnf a, b
Ghbgbcfnm d yfxfkj ckjdf ghtlgjcktly.. ,erde ckjdf 
Geyrn b gjvtyznm vtcnfvb dnjhjq b ghtlgjcktlybq cvdjk ckjdf
Ghbgbcfnm d yfxfkj ckjdf cnjkmrj ,erd c crjmrj ,erd d ckjdt
Pfvtybnm rf;le. ,erde a d ckjdt yf ldt gjcktljdfntkmyst ,erds a
Ghbgbcfnm r ckjde nfrjt ;t ckjdj pfgbcfyyjt d j,hfnyjv gjhzlrt
e) ghbgbcfnm r ckjde cghfddf nfrjt ;t ckjdj k hfp

3)
Yfgbcfnm vfibye nm.hbyuf dsxbckz.oe. aeyrwb. f(\omega) = 1 tckb \omega ghbyflkt;bn l, 0 tckb \omega yt ghbyflkt;bn l. ult jvtuf ghbyflkt;bn l

1) Zpsr l cjcnjbn bp ckjd gfkbylhjvjd d fkafdbnt a b
2) zpsr l cjcnjbn bp ckjd dblf a^n b^n
3) Zpsr l cjcnjbn bp ckjd a^n b^n c^n


\section{Dsxbckbvst gj nm.hbyue aeyrwbb}

\subsection{Gthdsq cgjcj, ghtlcnfdktybz lfyys}

D hfpltkt 2 ,skj ddtltyj gjyznbt bynebnbdyj dsxbckbvs[ aeyrwbq. Gjghj,etv ghbcgjcj,bnm gjyznbt vfibys nm.hbyuf lkz dsxbcktybz fhbavtnbxtcrb[ aeyrwbq.
Lkz 'njuj ytj,[jlbvj ljujdjhbnmcz j ghtlcnfdktybb xbctk yf ktynt. Ceotcndetn gj rhfqytq vtht ldf hfpkbxys[ cgjcj,f pfgbcb xbctk yf ktyne b bynthghtnfwbb htpeknfnf.

Hfccvjnhbv gthdsq cgjcj, ghtlcnfdktybz lfyys[ <eltv bcgjkmpjdfnm fkafdbn A = {0, 1}

Xbckj n ghbyflkt;fott n_0 gjlfdftvjt yf d[jl vfibys nm.hbyuf d rfxtcndt fhuevtynf ,eltv bpj,hf;fnm yf ktynt n+1 gjcktljdfntkmyjq tlbybxrjq
\bar{n} = 11..1 gecne. zxtqre j,jpyfxfnm s = 0. Gjcnegbv nfr lkz njuj xnj,s jnkbxbnm ghtlcnfdktybt yekz c gjvjom. tlbycndtyyjq tlbybxrb b ghtlcnfdktybt gecnjuj cbvdjkf
Gecnm n ghbyflkt;fofz N_0 pfgbcsdftncz yf ktynt ckjdjv \bar{n}
Gjcktljdfntkmyjcnm bp n+1 tlbybws njulf n_1 n_2 ... n_k ,eltn pfgbcsdfnmcz d dblt N_0^k \bar{n_1} 0 \bar{n_2} 0 ... 0 \bar{n_k}
Fhuevtyn aeyrwbb k gthtvtyys[ pfgbcsdftnz gjlj,ysv j,hfpjv. Rhjvt njuj gecnm U ytrjnjhfz rjyabuehfwbz vfibys nm.hbyuf njulf 1(U) dsxbckztn xbckj tlbybw d rjyabuehfwbb U. Ujdjhzn xnj vfibyf nm.hbyuf dsxbckztn aeyrwb.  f(x1, x2, x_k) tckb


Рассмотрим задачу нахождения наибольшего общего делителя.
Воспользуемся для решения задачи алгоритмом Евклида.

m = x
n = y

m = m
if (m > n) {
	m = m - n	
} else {
	n = n - m
}

Алгоритм евклида основан на следующих фактах, если x > y, то GCD(x - y, y) если x = y то GCD(x, y) = x = y, если x < y то GCD(x, y) = GCD(y - x, y)

Тело процедуры представляет собой последовательность операторов заключенных в скобки begin и end.
В теле используются три вида операторов операторы присваивания и цикла и условный оператор, покажем что эти виды операторов можно смоделировать подходящими комбинациями машин тьюринга также мы покажем как организовать передачу управления от одной машины тьюринга к другой.

Нам уже известно каким образом машины тьюринга могут вычислять простейшие арифметические функции и предикаты нам также потребуются машины для выполнения следующих элементарных действий. 

copy i
shL i
shR i

Печатает слово из i единиц справа от начальной ячейки и возвращает головку в начальное положение.
Перемещает головку на первую слева от входного вектора пустую ячейку копирует iтый блок единиц

(n1, n2, ..., ni-1, ni, ni+1, nk)
берет iтый компонент и устанавливает головку сразу же за последним сиволом справа на ленте

shL i перемещает головку через i блоков единиц влево
shR i перемещает головку через i блоков единиц вправо

На рисунке будет показано как сконструировать машину тьюринга из элементарных маши
На начальное состояние следующей за ней машиной, 

НОД (x, y) -> shr 2
	      copy 2 
	      copy 2
	      shL 2
	      equal

copy 2				copy 2
				copy 2
shL 2				shL 2
move 2, 1			greater
exit

		greater
copy 1				copy2
copy 3				copy2
shL 2				shL 2
monus				monus
move 1, 1			shr 1
shL 1				copy 2
start:				move 2,2
				start:
				
Формируют аргументы для простейших функций и предикатов
Удаляют ненужные блоки единиц чтобы лента была справа от последнего вычисленного результата
Были рассмотрены ранее. Сопоставляя эти два рисунка можно понять как пользуясь возможностью комбинировать элементарные машины тьюринга можно моделировать
основные операторы языка программирования выского уровня:
Операторы присваивания переходы и цикла и как следствие конструировать машины тьюринга выполняющие достаточно сложные вычисления

\subsubsection{Домашнее задание}:
\begin{enumerate}
\item составьте машины тьюринга их известных элементарных машин. f(x) = sqrt(x)
$$f(x) = 2^x $$

$$f(x) = log2(x)$$

$$f(x) = int(x) + 1$$

\item Напишите машину тьюринга вычисляющую предикаты
	1 если x простое
	0 если x составное

\item P(x, y) = 1 если x полный куб, 0 если нет
\end{enumerate}

\section{Тезис Тьюринга}
Изучая машины тьюринга выясняется что это весьма мощное вычислительное устройство, многие простые функции можно вычислить при помощи подходящей машины тьюринга
Более того машины тьюринга можно комбинировать для вычисления функций алгоритмы которых существенно сложнее

Свойства машин тьюринга позволяют предположить что они представляют собой предел вычислимости. Ценность работ тьюринга как раз в том что он задумал свою формальную модель алгоритма имея ввиду эту идею. Тьюринг предположил что любая интуитивно вычислимая функция вычислима по Тьюрингу. Предположение что машина тьюринга представляет собой предел вычислительных возможностей и следовательно является формальным уточнением понятия алгоритма получило название тезис Тьюринга. Возможно ли проверить тезис Тьюринга. Фундаментальная трудность лежит в интуитивно понятном понятием алгоритма не существует формального описания алгоритма. Тезис тьюринга не может быть формально доказан, однако он принимается за эмпирическую истину, понимая невозможность формального доказательства мы можем попытаться выступить в его защиту мы можем однако попытаться выступить в поддержку идей тьюринга.

Создавая и описывая алгоритм мы ориентируемся на некоторого абстрактного исполнителя, который должен быть способен выполнить последовательно шаги алгоритма. Более того мы не можем считать алгоритм полностью заданным пока каждый его шаг не будет понятен для исполнителя и однозначен исполнитель обязан четко знать какие действия и в какой последовательности он должен выполниить

Интуитивное понятие алгоритма такого что нам не трудно представить себе исполнение алгоритма человеком или машиной так объекты с которыми имеет дело исполнитель на каждом шагу должны быть элементами конечных множеств, с другой стороны очень важно чтобы исполнитель мог выбирать из произвольного количества возможностей. Вычисление даже элементарной тотальной функции x+1 требует от исполнителя умение оперировать с бесконечным множеством N_0, так как аргмент и результат вычисления этой функции могут принимать бесконечное множество различных значений. Это требование удается удовлетворить благодаря созданию входов выходов и промежуточных знаений алгоритма из конечных множеств. Шаги алгоритма также должны создаваться из конечного множетсва дискретных символов. Более того любой алгоритм может состоять только из конечного числа шагов. Таким образом исполнитель работает с конечным множеством символов, конечным множеством команд а также неограниченной памятью для своих записей.

Абстрактная машина тьюринга как раз и представляется собой реализацию такого рода рассуждений.
Каждая из двух других формальных нормальных алгоритмов Маркова и Рекурсивных функций определяет также класс функций которые могут быть описаны конечным числом команд. Предоставленных исполнителю формальной схемы. Еще раз напомним что все три подхода являются равноценными и задают один и тот же класс вычислимых функций. Этот результат является дополнительным сильным аргументом в пользу тезиса тьюринга. Аналогами тезиса Тьюринга для рекурсивных функций является тезис черча. А для нормальных алгоритмов Маркова принцип нормализации. но тезис тьюринга наиболее непосредственно убедителен. Действительно производя вычисления согласно избранному плану человек работает сходным с машиной Тьюринга образом:

Рассматривая какое либо место в своих записях и находясь в определенном умонастроении он делает необходимые изменения в написанном, проникается новым умонастроением и переходит к рассмотрению дальнейших записей.

Докажите что множество машин Тьюринга над конечным непустым алфовитом А счетно.
Докажите что множество слов в алфавите А не является счетным множеством.
Язык называется алгоритмически полным если на нем можно записать любой Алгоритм. Является ли язык программирования турбо паскаль 7.0 алгоритмически полным.

Неразрешимые проблемы:
Существуют два вида неразрешимых проблем - проблемы которые алгоретмически разрешимы но неразрешимы в реальном времени и проблемы алгоритмически неразрешимые:
Примером первой проблемы может послужить задача Коммивояжора. Если ее решать простым перебором то уже при достаточно малых N время которое требуется самому можному существующему компьютеру чтобы выполнить все действия сравнимо с геологической эпохой.
Когда мы говорит что проблема алгоритмически неразрешима это означает что согласно тезису тьюринга что ее решение невозможно представить в терминах вычислимой функции:
Другими словами не существует машины тьюринга которая вычисляла бы функцию представляющую проблему, здесь важно отметить что когда мы говорим о некоторой проблемы, мы говорим что она неразрешима это означает что не существует машины тьюринга решающий ее для каждого случая. Однако вполне могут существовать машины тьюринга решающие проблему для некоторых частных случаев.

В самом деле неразрешимость некоторой проблемы для несущественных с точки зрения практики не является для нас существенным ограничением. Тем не менее знания о неразрешимости данной проблемы позволяет не занимать поисками общего решения и объясняет почему решения для частных случаев часто найти очень непросто.

Рассмотрим пример алгоритмически неразрешимой проблемы: все машины тьюринга использующие один алфавит A можно расположить в последовательность присвоив каждой машине тьюринга номер так что его можно найти с помощью какого нибудь алгоритма. С другой стороны в этом случае можно по номеру машины тьюринга восстановить саму машину. Дальнейшие рассуждения относятся к первому способу представления данных. Пусть для определенностя A ={0, 1} F(T) выдает номер машины тьюринга T на алфавитом А. Возможны два случая: случай А - существует вычисление на машине T начинающееся с конфигурации. fi A* -> A* / $q_0$ $N_0$ (T) в этом случае говорят что машина T останавливается на своем номере. 

Пункт Б - не существует вычисления на машине T начинающиеся с этой конфигурации. Тогда говорят что машина T не останавливается на своем номере - в случае A машина называется самоприменимой, в случае B - несамоприменимой.

Сформулируем проблему самоприменимости - существует ли алгоритм тьюринга, который по номеру машины тьюринга отличает применимые от самоприменимых. То есть вычислима ли функция

f(x) = 1, если x = номеру самоприменимой машины, 0 если x = номеру несамоприменимой машины.

Попытаетмся решить данный вопрос на основе тезиса тьюринга.

\subsection{Теорема 1}: 

Проблема самлприменимости неразрешима, не существует алгоритма отличающего по номеру самоприменимых машины от несамоприменимых.

\textbf{Доказательство}

Предположим противное - пусть машина T вычисляет функцию f(x) машину T можно построить таким образом что для некоторого индекса s каждая заключительная конфигурация имеет вид $q_s0$ или $q_s1$
Рассмотрев машину T' Добавив к командам T команду $q_s$ 1 1 $q_s$. Машина $T'$ отличается от машины $T$ тем что она не останавливается на самоприменимых машинах 
Является ли $T'$ самоприменимой?
Тогда она не останавливается на своем номере, тогла по определению саомоприменимых машин она не является самоприменимой


Предположим что $T'$ не самоприменима, значит она не должна останавливаться на своем номере, однако по построению машина T' не останавливается только на номерах самоприменимых машин. 
Тогда она останавливается на своем номере и следовательно самоприменима. Полученое противоречие доказывает теорема.

Следующий пример относится ко второму способу представления данных. Еще один пример неразрешимой проблемы - проблема останова,
 остановится ли данная машина тьюринга T начав свою работу с ленты L иначе говоря вычислима ли функция
  H(T, L) = { 1 если машина t останавливаетася на входной ленте, 0 если не останавливается  

Теорема 2.
Проблема останова неразрешима(Не существует алгоритма определяющего для машины T и входной ленты L) остановится ли машина получив на вход ленту L.
Доказательство - предположи что проблема L разрешима. Т.е. существует машина тьюринга L, которая вычисляет функцию h(L, T)

Машина h должна иметь конечный алфавит и конечное множество команд, следовательно машина h должна обрабатывать описания машин и лент выраженных с помощью своего алфавита.
Предложим способ описания машин и лент. Будем обозначать машины цепочками сиволов представляющими список команд.

Кодируя каждую команду будем использовать двоичный код для состояний и символы ленточных алфавитов.
Для описание лент воспользуемся последовательностями из ленточных символов отделяя каждый символ от последующего некоторой зафиксированной буквой
Пусть V и W множества описаний машин и лент соотвественно в кодировке используемой машиной Ш. Предположим что D от T описания машины T в V. $D(L)^$ описание ленты L в W.
Тогда от начальной конфигурации $q_0$ 0 D(T) 0 $D(L)^0$ машина H переходит к заключительной конфигурации $q_z$ 0 $\phi$ 0 где

\phi = { 1 если мащина T останавливается на ленте L , 0 - если не останавливается }

Если машина H работает правильно длялюбых пар (D(T), $D^(L)$), то она работает правильно и для тех пар которых L = D(T) то есть для пар представляющих машину тьюринга которая начинае работу с описания самой себя. Тогда $D^(L)$ = $D(D(T))$.

Поскольку перекодировка D(T) в $D^(T)$ может быть выполнена на подходящей машине тьюринга лента содержит избыточную информацию. Может быть эффективно получен из первой.

Ограничем дальнейшее рассмотрение машинами которые получают на вход ленты такие что $D^(L)$ = $D(T)$

Построим машину H' которая получает на вход пару (D(T), D(T)) это значит что машина H вычисляется функцию h'(t) = 1, если t останавливается на описании самой себя и 0 если не останавливается. Замечаем, что машина h' фактически решает проблему самоприменимости. В качестве номера машины используется ее описание в некотором двоичном коде. Но теорема 1 отвергает саму возможность решения проблемы самоприменимости полученное проиворечие доказывает что и проблема останова неразрешима.

\section{Понятие о вычислительной сложности алгоритма}
Мы выясняли вопрос о том каким образом можно выяснить какая проблема может быть разрешима - пусть задана функция f, пусть также установленоо что функция f - вычислима иначе говоря построен вычисляющий ее алгоритм, в реальных вычислениях - главный вопрос относительно функции состоит в том вычислима ли f - практически. Иными словами существует ли программа вычисляющая функцию f за время или в том объему памяти в котором мы располагаем ответ отчасти зависит от нашего мастерства в написании программ и возможностей наших компьютеров, но интуитивно мы чувствуем что имеется дополнительный фактор который можно называть внутренней сложностью присущей функции F подобные вопросы рассматривает теория вычислительной сложности ее два направления абстрактная и прикладная теория сложности.

Абстрактная теория сложности является разделом теории рекурсивных функций и рассматривает различные подходы к понятию вычислительной сложности сложность процесса применения алгоритма к исходным данным называется вычислительной сложностью и сложностью вычислений процесс вычисления зависит от исходного объекта к которому применяется алгоритм поэтому сложность вычислений алгоритма есть функция сопостовляющая каждому объекту из области применения данного алгоритма число характеризующее сложность процесса применения алгоритма к данному объекту.

Такая функция называется сигнализирующей. Существуют различные способы задания сигнализирующих функций.
Наиболее важные характеристики сложности работы алгоритма. Длительность алгоритмического процесса и объем промежуточных результатов. 

\section{Прикладная теория сложности}

Рассматривает сложность тех классов задач которые требуется решить на практике. Исследуя прикладные задачи дискретной математики как правило можно найти алгоритмы для их решения. Например с помощью некоторого процесса перебора. Однако при этом число шагов растет с увеличением размерности задачи и последняя становится практически неразрешимой. Есть целый ряд задач представляющих практический интерес для которых по-видимому не существует эффективных алгоритмов.  А про имеющиеся разрешающие алгоритмы можно сказать, что они не эффективны даже при реализации на компьютерах ближайших будущих поколений.

Далее мы будем оценивать алгоритмы лишь по временной сложности. Из курса высшей математики известно что. что функция f(n) есть O(g(n)) если существует константа k такая что |f(n)| <= k(g(n))

Полиномиальным алгоритмом или алгоритмом полиномиальной временной сложности называется алгоритм у которого временная сложность O(P(n)), где P(n) - некоторая полиномиальная функция от входной длины n. Алгоритмы для временной сложности которых не существует такой оценки называется экспоненциальными. Задача считается трудно решаемой если для нее не существует разрешающего полиномиального алгоритма. Таблица оценки зависимостей времени работы алгоритма сложности равной n, $n^3$, $2^n$ от размеров входной информации, а также оценки максимальнйо размерности задачи решаемой за один час.

размерность            10           20                50                            60
n			0.00001     0.00002           0.0005			    0.00006
$n^3$			0.01        0.00008	      0.125			    0.216
$2^n$			0.01	    1		      35.7 дней			    366 столетий


Функция временной сложности         современный компьютер	компьютер в 100 раз более быстрый компьютер еще в 100 раз более быстрый
n 					N1				100 N1				1000N1
$n^3$					N2				4.64 N2				10 N2
$2^n$					N3				N3 + 464N3			N3 + 9.99N3


Из последней таблицы видно что не дает существенного роста разрешимости задач если алгоритм имеет экспоненциальную сложность. Многие прикладные задачи могут быть сформулированы в терминах теории графов. (Число вершин n число ребер m) характеристики графика велики и их анализ возможен лишь с применением вычислительной техники.

Задачи теории гарфов по временной сложности алгоритмов можно классифицировать следующим образом.
\begin{enumerate}

\item Задачи для которых имеются сложности $O(n+m)$
К первому классу относятся следующие задачи: выделение компонентов связности и сильной связности орграфа. Нахождение минимального пути в орграфе или минимальной цепи в графе. Или нахождение эйлерова цикла.

\item Задачи для которых известны алгоритмы сложности O(P(n+m)), где P(n) нелинейный полином
Второй класс включает в себя такие задачи: нахождение матрицы связности, сложность $O(n^3)$, Нахождение минимального пути  в нагруженном графе.

\item Задачи для которых известны только алгоримты экспоненциальной сложности, но про которые нельзя сказать что для них нет алгоритмов полиномиальной сложности. Задачи которые могут быть решены лишь с использованием алгоритма экспоненциальной сложности. Разбиение задач на первые три класса зависит от мастерства математика.
Третий класс содержит задачу о существовании в графе гамильтонова цикла, задачу коммивояжора, задачу об определении изоморфизма графа $g_1$ какому нибудь подграфу графа $g_2$.
К этому же классу относится задача о выполнимости формулы логики высказываний записанной в конъюктивной нормальной форме.

\item Задачи четвертого класса принципиальо нельзя отнести к первым трем классам. К четвертому классу относятся в частности задачи перечисления всех циклов графа.
Для решения этих задач неизвестны полиномиальный алгоритмы. Хотя не кажется безусловным что их решение возможно лишь с помощью экспоненциальных алгоритмов.

\end{enumerate}


В современной дискретной математике третий класс задач является предметом пристального изучения. Итого: наиболее значимыми для практике стали модели алгоритма предложенные тьюринга а также черчем и марковым. Заслугой тьюринга является не только то что он нашел строгий способ моделирования алгоритма, но и предвосхитил многие принципы функционирования современной вычислительной техники. Одним из важнейших путей развития теории алгоритмов является теория сложности вычисления. Знание основных неразрешимых проблем теории алгоритмов стало одним из существенных моментов. По существу это знание дает понимание того что можно и чего нельзя сделать при помощи компьютера.

Язык E = {\eps} есть единица конкатенации языков например этот же язык A = A. Однако для любого языка справедливо A*\empty = {\omega*\phi | \omega принадлежит A \phi принадлежит \empty} = \empty

Таким образом пустой язык и язык E содержащий единственную цепочку \eps - два различных языка некоторые совйства конкатенации языков.

1) Операция конкатенации языков ассоциативна
Для любого L1, L2, L3 содержащиеся в V*. 
2) Язык E равный {\eps} является единицей конкатенации языков, то есть для любого L, содержащегося в L* = LEL = L

3) Пустой язык является нулем конкатенации языков. То есть для любого L 
\empty L = L \empty = \empty

4) Операция конкатенации языков над алфавитом состоящим из более чем одного символа некоммутативна. То есть существует L1 <= V* L2 <= V* (L1L2 != L2L1)

5) Операция конкатенации языков дистрибутивна относительно объединения
Для любого L1, L2, L3 из L1(L2 U L3) = (L1 * L2) U (L1 * L3)
Однако операция конкатенации языков не дистрибутивна относительно пересечения.
Введем еще одну операцию над языками.
Пусть V - произвольный алфавит. Для языка L содержащегося в L* определим множество цепочек $L^k$. Где K >= 0, K принадлежит Z следующим образом:
L ^ 0 = E
L ^ 1 = L 
L ^ 2 = LL
L ^ K+1 = L ^ K L

Каждый из языков L ^ k является подмножеством
V* так как V* замкнуто относительно конкатенации

Объединение этих языков L* =  U_k=0^\inf L ^k так же является подмножеством V* - множество всех цепочек над алфавитом V
Множество L* назвается итерацией или замыканием Клини языка L. Таким образом замыкание L состоит из всех цепочек, которые можно получить в результате конкатенации произвольного числа цепочек языка L.
Пример 1.4 L = a
Тогда L^2 = L*L = aababaabab

L^3 = L^2*L = aaaaaabaabaaabababaaaaabbababab

Пример 1.5
Пусть язык A состоит из единственного симовол a, B из двух {0, 1}
A* = {\eps, a, aa, aaa, ...} = {a^k, k >= 0, k принадлежит Z}

B* = {\eps, 0, 1, 00, 01, 10, 11, 001, ...} = {{0}*{1}}

Напомним что A* и B* множества всех возможных цепочек над языком A и над языком B соотвественно.
Символом V+ будем обозначать V* - E
L+ = L* \ E
Для языка полученного замыканием языка
L за вычетом E.

Операцию L+ над языком L часто называют позитивной итерацией. Заметим что L+ = LL* = L*L

Обращение языка L состоит из всех цепочек являющихся обращениями цепочек языка L. То есть L^r = {w^r | w принадлежит L}

Пусть L язык над алфавитом V. Рассмотрим язык M, который M = { ww^r | w принадлежит L \subset V*}

Каждая цепочка языка M является обращением самой себя. Поэтому язык M часто называют зеркальным. Если все цепочки некоторого языка L имеют вид \omega * \omega^r
то L = L^r. Обратное не верно. Если L != 10 01
L^r= 01 10. Однако L цепочек L\omega нет.

Часто бывает удобно представлять языки через объединение, конкатенацию, и, или. Замыкание языков состоящих только из символов данного алфавита. Например,
L = ({0}{0, 1})* 
Есть язык состоящий из всех цепочек, получающихся при замыкании языка {0}{0, 1} = {00, 01} такие выражения упрощают опусканием фигурных скобок.

= (0 * (001))*. Такие выражения эквивалентны стандартному теоретико множественному представлению языка L. К сожалению, один и тот же язык часто бывает можно представить несколькими способами. Причем далеко не всегда очевидно что такие представления описывают одно и то же множество цепочек. Например 0, (10)* и (01)* 0 описывают один и тот же язык.

1) Проверить

\section{Формальные грамматики}
Уже длительное время автоматический перевод текста с одного языка на другой является одним из предметов интереса как математической лингвистики так и компьютерных наук.
Годы вредществующие появлению языков программирования выского уровня стали свидетелями активных исследований по формализации языков. Хотя цель качественного перевода с одного языка на другой остается недостижимой результатом этих исследований стала теория формальных грамматик она оказала существенное влияние на создание удобных для общения с компьютером искусственных языков - языков программирования. Основоположником теории формальных грамматик считается американский математик и лингвист Хомский. Именно он указал на возможность использовать для описания естественных языков некоторое исчисление рассматриваемые ранее в теории алгоритмов, но не игравшие там существенные роли. придав им удобную для этого форму. Он же ввел в рассмотрение специальные классы порождающих грамматик, которые представляют наибольший интерес и указал пути их использования. Он также положил начало математического исследования формальных грамматик введя некоторые важные понятия. И доказав ряд основных факторов. Далее мы рассмотрим основные понятия теории формальных грамматик, а также связь этих понятий с языками, которые они описывают. Хотя к настоящему времени изучено много разнообразных типов грамматик и языков. Основное внимание будет уделено четырем основным классам языков и порождающих грамматику. Иерархия хомского

Пункт 2.1 при описании языков с помощью формальных методов мы сталкиваемся с серьезнейшей проблемой - бесконечным количеством цепочек (предложений) языка.
Чтобы описать язык нам пришлось бы выписать все возможные предложения языка, что вряд ли возможно. Конечно никому не пришло бы в голову все синтаксически правильные программы на языке паскаль. Для того чтобы на языке паскаль предоставить пользователю возможность выбрать для себя подходящую таким образом центральная проблема описания языка найти способ конечного описания языка для существенного бесконечного класса объектов.
Для данного алфавита V  множество V* состоит из всех возможных цепочек из символов алфавита V.
Формальный язык L это произвольное подмножество множества V*. наша задача найти такое представление языка L. Которое представляет проверить является ли данная цепочка из V* словом языка L.
заметим что при поиске представления языка нас не интересуют вопросы связанные с семантикой(смысловыми значениями) предложений языка. В то же время мы увидим что структура предложений получаемая на основе искомого представления языка как правило соотвествует интерпретации придаваемой предложением пользователя. Для русского языка алфавит может состоять из 33 пар букв.

Строчных и прописных. 10 цифр. символа пробела. набора знаков препинания. В качестве формальной грамматики для русского языка можно взять конечное множество правил построения предложений языка. Для языка программирования алфавит состоит из множества всех неделимых символов, которые могут использоваться в программе. Предложениями в языке программирования обычно считают любую цепочку символов алфавита представляющую собой законченную программу. Удовлетворительная грамматика для языка программирования. Удовлетворительная грамматика для языка программирования должна определять с помощью механической процедуры соответсвует ли произвольная последовательность символов понятию синтаксически правильной программы. Требование конечности представления языка столь строгое что существует бесконечное множество языков не имеющих такого представления. Так как множество языков над алфавитом V - это множество всех подмножеств множества V* и следовательно оно имеет мощность cont. С другой стороны  как будет показано ниже число конечных представлений языков не более чем счетно, следовательно несчетное количество языков не имеет конечного представления. Этот факт не должен огорчать нас так как языки не имеющие конечного представления как правило не обладают упорядоченной структурой и вслодовательно вследствии этого не представляют интереса.

Пункт 2.2

Пример из языка 

Понятие грамматического представления естественного языка на интуитивном уровне знакомо каждому школьнику изучающему например английский язык.
Предложения языка строятся на основе последовательного применения грамматических правил. Правила определят каким образом предложение или его часть далее будем называть ее фразой можно записать как конкатенацию составляющих ее компонентов.
Так же являющихся фразами, например предложение

jack and jill run up the hill
<           > <             >
Это конструкция может быть выражена следующим грамматическим правилом.
<предложение> -> <группа подлежащего><группа сказуемого>
Суть этого правила состоит в том что фраза типа <предложения> может быть переписана как конкатенация фраз группа подлежащего  и группа сказуемого.
Мы написали названия фраз в угловых скобках чтобы избежать путанницы со словами и символами самого языка фраза группа подлежащего в рассматриваемом примере состоит из пары существительных соединненых союзом, эту конструкцию можно представить в виде грамматического правила <сущ><союз><сущ> однако мы предпочтем правило которое представляют структуру максимально возможного числа фраз

2.

<группа подлежащего> -> <подфраза существительного>

3. 
<подфраза существительного> -> <существительное>

<подфраза существительного> -> <существительное><союз><подфраза существительного>
